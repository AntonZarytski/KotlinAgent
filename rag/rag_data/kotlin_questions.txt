Kotlin/Java
1. Основные фишки языка Kotlin по сравнению с java
1. Null-safety (борьба с NPE)
В Kotlin каждая переменная либо nullable, либо не nullable:
Работаешь с nullable - компилятор заставляет тебя явно обработать null:
* ?. - безопасный вызов (вернёт null, если слева null)
* ?: - оператор Элвиса (подставляет значение по умолчанию)

Это убирает целый класс NPE-багов.
2. val / var и акцент на неизменяемость
3. Свойства вместо полей + геттеры/сеттеры
4. Smart cast (умные приведения типов)
5. Extension-функции (расширение чужих классов)
6. Higher-order функции и лямбды
7. Coroutines (корутины)
Не чисто «синтаксический сахар», но ключевая фича Kotlin по сравнению с Java.
   * Лёгкие «потоки» на уровне языка
Пишешь асинхронный код как синхронный:

8. Sealed-классы, when, data-классы
Sealed-классы (ограниченная иерархия)
Data-классы
В Java надо писать equals/hashCode/toString/copy руками.
      * Сахарные фичи String $templates, Ranges и циклы, when вместо switch
9 Scope-функции (let, run, apply, also, with)
10. Функции вне классов (top-level functions)
2. Чем Kotlin хуже чем java
1. Скорость компиляции и сборки
Kotlin обычно компилируется медленнее Java, особенно:
      * большие multi-module проекты;
      * использование kapt;
      * много generics, inline, корутин и пр.
В Android это чувствуется:
      * дольше assembleDebug / assembleRelease;
      * может хуже работать incremental compilation, чем у Java-модулей.
В чисто Java-проекте инкрементальная компиляция часто стабильнее и быстрее. Kotlin добавляет слой сложности компилятору, из-за чего сборка может быть более тяжёлой.


2. KAPT и аннотационные процессоры
Одна из самых болезненных тем.
      * kapt — адаптер, который позволяет Java-аннотационным процессорам (Dagger, MapStruct, Room старых версий и т.п.) работать с Kotlin.

      * Он фактически:
         * генерит Java-stubs,
         * прогоняет через Java APT,
         * потом всё это компилирует.

            * ksp вместо kapt, но:
            * не все библиотеки мигрировали;
            * ksp всё равно добавляет стадии обработки.
3. Отладка и stacktrace’ы
Kotlin добавляет:
            * встроенные функции (scope-функции, collection-операции),
            * coroutines,
            * inline-лямбды и пр.

В итоге:
               * stacktrace’ы могут быть длиннее и менее очевидны (особенно с корутинами и suspend);
               * иногда сложнее понять, где именно ошибка, если всё замешано на let/run/apply/flow и т.д.;
               * часть вызовов сворачивается инлайном, и трейс становится «не прямолинейным».
4. Kotlin позволяет писать очень выразительный код, но это палка о двух концах. Если нет дисциплины и code review, кодовая база может стать более запутанной, чем эквивалент на Java.
3. Kapt vs ksp
Что делает kapt(Это “Kotlin притворяется Java-проектом”.):
               1. Ты пишешь Kotlin-код.
               2. kapt генерирует Java-stubs (заглушки) для твоих Kotlin-классов.
               3. Эти stubs скармливаются Java-аннотационным процессорам (Dagger, Room, Glide и т.д.).
               4. Процессоры генерируют Java-код.
               5. Потом уже компилируется и твой Kotlin, и сгенерированный Java.

ksp(Kotlin Symbol Processing Kotlin 2+)
                  * KSP встраивается не через Java-компилятор, а на стороне Kotlin-компилятора.
                  * Он работает с символами Kotlin напрямую: классы, функции, аннотации, параметры, nullability и т.д.
Упрощённая схема:
                  1. Kotlin-компилятор парсит твой код и строит модель (символы).
                  2. KSP-процессоры читают эту модель (Kotlin-символы).
                  3. Генерируется исходный код (Kotlin/Java).
                  4. Всё это компилируется обычным образом.
То есть нет слоя Java-stubs, меньше обвески.
3. Context receiver/parameters
Context receivers / context parameters в Kotlin позволяют объявлять у функции «скрытые» зависимости от окружения.
Вместо того чтобы передавать Logger, Database, UserService в каждый вызов, мы объявляем их как контекст, через context(...). Внутри функции они доступны как обычные переменные, а компилятор следит, чтобы функция вызывалась только там, где этот контекст есть.
На байткоде это обычные дополнительные параметры функции, но на уровне языка мы получаем более чистые API, удобные DSL и безопасное использование сервисов без постоянного проброса аргументов.


Context receivers хорошо сочетаются с DI, но не заменяют его. DI-фреймворк создаёт и управляет зависимостями (граф, скоупы, lifecycle), а context parameters дают удобный и типобезопасный способ передавать эти зависимости по коду без постоянного проброса в аргументах.
Функции объявляют, какой контекст им нужен, а DI отвечает за то, чтобы этот контекст был доступен на уровне вызова.
4.  Особенности системы типов Kotlin(все является классом, нет Object, топ класс Any, есть mutable/imutable колекции) как в JVM они приводятся
в Kotlin нет примитивов! Работаем как с объектами

                  * Int (не nullable) → примитив int в локальных переменных, полях, параметрах, когда generic-ов нет.
                  * Int? (nullable) → обёртка java.lang.Integer (boxing), т.к. примитив не может быть null.
                  * В generic-ах всегда используются обёртки: List<Int> на JVM → List<Integer>.
                  Any?                          ← самый верхний тип
                 /    \
              Any    Nothing?                   ← нижний для всех T?
            /  |  \
     Int  String Unit  ...                   ← обычные классы / примитивы (не-null)
           \    |    /
          Nothing                             ← нижний тип для всех не-null T


В Java:
        •        топовый тип: java.lang.Object
В Kotlin:
        •        топовый не-null тип: Any
        •        топовый nullable тип: Any?




Kotlin - Java - JVM работает при помощи анотаций @NotNull


Колекции
        •        read-only: List<T>, Set<T>, Map<K, V>
        •        mutable: MutableList<T>, MutableSet<T>, MutableMap<K, V>


Ключевая фишка — это контракт на уровне типов, а не гарантированная неизменяемость реализации.


На JVM


Почти всегда и те, и другие — это обычные java.util.*:
        •        List<T> / MutableList<T> → java.util.List
        •        Set<T> / MutableSet<T> → java.util.Set
        •        Map<K,V> / MutableMap<K,V> → java.util.Map
                  * Unit в Kotlin — аналог void, но как реальный тип(с одним единственным значением: Unit. Класс в рантайме: kotlin.Unit с синглтоном Unit.INSTANCE.
На JVM обычная функция (): Unit компилится как void, но сам Unit существует как класс kotlin.Unit с синглтоном Unit.INSTANCE и используется в generic-ах и типах функций (Function0<Unit> и т.д.).
                  * Nothing — тип без значений, «функция с таким return type никогда не возвращается». Нельзя создать
val x: Nothing = ??? // невозможно, нет ни одного значения
На JVM это обычный метод с каким-то ссылочным return type (часто Void), который внутри всегда делает throw или бесконечный цикл. Компилятор использует Nothing для анализа потока управления (smart cast, when без else), а в рантайме никакого значения этого типа не существует.
Выражение типа Nothing можно использовать в любом месте, где ожидается значение любого типа, но на самом деле код туда не доходит, потому что выполнение прерывается.
5. "!" - это platform types, возвращается если нет анотации в Java
Это не синтаксис языка и не оператор, а внутреннее обозначение типа, который:
Может быть как String, так и String?, и компилятор не навязывает тебе проверки.
Ты его видишь только в подсказках IDE / в ошибках компилятора.
В Kotlin Type! означает platform type — тип, пришедший, как правило, из Java, для которого компилятор не знает, nullable он или нет. Например, когда в Java нет или непонятны аннотации @Nullable/@NotNull.
Platform type можно использовать и как T, и как T?, компилятор не заставляет нас делать проверки на null, но тогда ответственность за возможный NPE на нас.
6. Динамическая типизация Kotlin


Kotlin — статически типизированный язык с мощным выводом типов. Типы проверяются на этапе компиляции, как в Java, а не в рантайме, как в Python или JavaScript.


На JVM-таргете у Kotlin нет полноценной динамической типизации, но есть механизмы, которые выглядят “динамично”: общий тип Any, проверки is, касты as/as?, smart cast’ы. То есть мы можем работать с разными runtime-типами через один параметр Any, но типы всё равно строго проверяются компилятором.


Настоящий dynamic существует только в Kotlin/JS: там есть специальный тип dynamic, который отключает статическую проверку типов и работает по правилам JavaScript. В Android/JVM-коде он недоступен, и вся типизация остаётся статической.


В Kotlin List — это не настоящая immutable-коллекция, а read-only интерфейс над обычно мутируемой java.util.List. Через другой reference или Java-код коллекцию всё равно можно изменить.


Поэтому есть отдельные артефакты с настоящими immutable/persistent коллекциями, например kotlinx.collections.immutable.ImmutableList или Guava ImmutableList. Они гарантируют, что после создания структура больше не меняется, и любые “изменения” возвращают новый объект. Это важно для thread-safe кода, функционального стиля и безопасных публичных API.


Эти коллекции вынесены в отдельный модуль, потому что не всем они нужны по умолчанию, они тяжелее реализационно, и это позволяет развивать их независимо от стандартной библиотеки, не ломая совместимость.


Почему не запихнуть это в stdlib и не назвать просто List?
3.1. Совместимость с Java и старым кодом
                     * List в Kotlin завязан на java.util.List.

                     * Если бы внезапно сделали List реально immutable,

половина SDK и всей Java-экосистемы просто перестала бы работать как ожидается.

                     * Kotlin изначально проектировался как “first-class гражданин JVM”, поэтому List/MutableList максимально совместимы с Java.

7. Типы для функционального програмирования Kotlin - fun(это как object), в fun переменную можно сохранить лямбду, анонимная функцию, функциональный интерфейс(runnable)
В Kotlin функция — это значение. Её можно положить в переменную, передать в аргумент, вернуть из функции.
Тип для этого в Kotlin записывается так:
val f: (Int) -> String = { x -> x.toString() }      // лямбда
val g: () -> Unit = { println("Hello") }           // лямбда без аргументов
val h: (String, Int) -> Boolean = { s, i -> s.length == i }
Что можно положить в переменную функционального типа
В переменную типа (A) -> B можно положить:
                        1. Лямбду:
val f: (Int) -> Int = { it + 1 }
                        2. Анонимную функцию:
val f: (Int) -> Int = fun(x: Int): Int {
        return x + 1
}
                        3. Ссылку на функцию (function reference)
fun inc(x: Int) = x + 1
val f: (Int) -> Int = ::inc
В Kotlin функции — это значения, для них есть отдельные функциональные типы: (A, B) -> R, () -> Unit, suspend (T) -> R и т.д.
Переменная такого типа может хранить лямбду, анонимную функцию или ссылку на обычную функцию. На JVM эти типы реализуются через интерфейсы FunctionN.
Отдельно есть функциональные интерфейсы (SAM) — как Java Runnable или Kotlin fun interface. Когда код ожидает такой интерфейс, мы можем передать обычную лямбду — компилятор сам сгенерирует реализацию интерфейса.


На JVM функциональные типы Kotlin, такие как () -> Unit, реализуются через интерфейсы FunctionN (Function0<Unit>). Лямбда в таком случае компилируется в класс, реализующий Function0 и метод invoke.
Для Java-стека есть SAM-интерфейсы вроде Runnable или Kotlin fun interface. Там лямбда компилируется в класс с методом run(). Это разные типы: () -> Unit ≠ Runnable. SAM-конверсия срабатывает только когда параметр объявлен как SAM-интерфейс. Поэтому в Kotlin-ориентированных API используем функциональные типы, а для Java-интеропа — SAM-интерфейсы.
8. Что такое функциональный интерфейс(что бы он был функциональный, должна быть как минимум одна функция без дефолтной реализации)
Функциональный интерфейс — это интерфейс с ровно одним абстрактным методом. Остальные методы могут быть default или static, они не мешают. Такой интерфейс совместим с лямбдами: компилятор может взять лямбду и сгенерировать под неё реализацию этого интерфейса. В Java это SAM-интерфейсы, часто с аннотацией @FunctionalInterface, а в Kotlin есть специальный синтаксис fun interface для объявления таких интерфейсов.


9. Sealed классы/интерфесы - что такое, зачем, особенности наследования, отличие от enum(могут содержать доп поля и логику, только конкретные экземпляры)


Sealed классы и интерфейсы в Kotlin — это “закрытые” иерархии типов. Ключевая идея: компилятор знает все возможные подтипы, потому что они должны быть объявлены в том же модуле и пакете. Это даёт нам безопасные when без else и удобно для моделирования состояний вроде Success/Error/Loading, где каждому варианту нужны разные данные.


В отличие от enum, который ограничивает фиксированный набор экземпляров одного типа, sealed-класс ограничивает набор подтипов. Каждый подтип может иметь свои поля и логику. В enum все константы имеют одну и ту же структуру полей, и каждая — единственный singleton. Sealed-подтипы могут иметь сколько угодно экземпляров и чаще используются вместе с data class и object для построения “сумм типов”.
10. Во что конвертируется в jvm sealed класс(в абстрактный класс, потому-что java ничего не знает про фичи котлина и для нее это абстрактный класс)
Ключевые моменты:
                        * Result → abstract class.
                        * Подклассы → обычные final-классы, наследующие Result.
                        * Информация о том, что Result — именно sealed и какие у него наследники, зашита в:
                        * @kotlin.Metadata,
                        * внутренней структуре, которую понимает компилятор Kotlin, а не JVM.
Java как платформа ничего не знает про “sealed Kotlin-стайл”. Для неё это просто:
                        * абстрактный класс,

                        * с каким-то конструктором и финальными наследниками.
11. inline/crossinline функции - зачем нужны, как применяются, как понять что нужна(если большая функция, то лучше не надо) - что бы подставлять функцию(не лямбда и анонимный класс) в место вызова
inline в Kotlin говорит компилятору подставить тело функции и переданные ей лямбды прямо в место вызова. Это убирает аллокации лямбда-объектов и вызовы invoke, а также позволяет использовать reified generic-и и нелокальные return из лямбд.


Использовать inline имеет смысл для маленьких, часто вызываемых higher-order функций (scope-функции, утилиты, корутинные helpers). Для больших функций инлайн может только раздуть байткод.


crossinline применяется к параметру-лямбде в inline-функции, чтобы запретить из неё нелокальный return, но при этом всё ещё инлайнить код. Это важно, когда лямбда вызывается позже или в другом контексте.


inline fun crossinlined(crossinline block: () -> Unit) { block() }
inline fun inlined(block: () -> Unit) { block() }
fun normal(block: () -> Unit) { block() }


fun test2() {
    crossinlined {
//      return // 🚫 ЛОКАЛЬНЫЙ return из test2 запрешен
        return@crossinlined
    }
    inlined {
        return // ✅ НЕЛОКАЛЬНЫЙ return: выходим из test2()
        return@inlined
    }
    // unreachable code
    normal {
//        return // 🚫 ЛОКАЛЬНЫЙ return из test2 запрешен
        return@normal
    }
}


12. Зачем нужен reified, пример: inline fun <reified T> myGenericFun(), как работает каст с reified/без. только для inline, для функции не происходит стирание типов, можно вызвать например classname


В обычных generic-функциях на JVM тип-параметр T стирается из-за type erasure, поэтому внутри функции мы не можем делать value is T, T::class, T::class.java и т.п.


reified работает только в паре с inline: компилятор подставляет конкретный тип вместо T в месте вызова, генерируя фактически отдельную версию функции для T = String, T = Int и т.д. Поэтому внутри inline fun <reified T> можно делать проверки is T, брать T::class, T::class.java, строить type-safe касты и т.п.


На JVM type erasure никуда не девается глобально, но для inline+reified-функций компилятор “протаскивает” информацию о типе до call site и зашивает её прямо в сгенерированный код.


Type erasure = компилятор выкидывает информацию о generics на этапе компиляции, и в рантайме всё становится “как будто без generics”.


         kotlin
fun <T> first(list: List<T>): T {
    return list[0]
}
bytecode
Object first(List list) {
    return list.get(0);
}
Зачем: generics в Java(6)/JVM прикрутили задним числом, не ломая старый байткод и старые библиотеки.
                           * generics сделали чисто на уровне компилятора;
                           * байткод остался совместимым: всё те же List, Object, (Integer)-касты.

13. Особенности написания кода в KMP(код разделен на - common и платформенные сорсеты), expect/actual функции


commonMain
  ├─ бизнес-логика (use-cases, domain)
  ├─ общие модели, sealed-классы, DTO
  └─ expect-API (то, что зависит от платформы, но спрятано за интерфейсом)


androidMain / iosMain / jsMain ...
  └─ реализация платформенных частей (actual)


Идея:
        •        максимум логики держим в commonMain;
        •        в платформенных сорсетах только то, что действительно зависит от платформы:
        •        файловая система,
        •        сеть (если не используем мультиплатформенную библиотеку),
        •        дата/время, storage, UI-хуки, логирование, и т.п.


common-код не знает деталей платформы, но он может использовать платформенное API через expect/actual-мост.


В KMP код разбивается на общий сорсет (commonMain) и платформенные (androidMain, iosMain и т.д.). В commonMain мы держим всю бизнес-логику и модели, а платформенные сорсеты содержат только то, что завязано на конкретный SDK.


Для доступа к платформенному функционалу из общего кода используются expect/actual декларации. В commonMain объявляем expect-класс или функцию — это контракт, а в каждом платформенном сорсете даём actual-реализацию с той же сигнатурой. Компилятор следит, чтобы для всех таргетов были реализации, и подставляет нужную при сборке.


Таким образом, общий код работает с абстракцией (например, SecureStorage, PlatformInfo, currentTimeMillis), а конкретная реализация живёт в android/ios-коде. В идеале 80–90% логики — в commonMain, а expect/actual используются только там, где реально нужно залезть в API платформы.
expect/actual и интерфейсы решают разные задачи. Интерфейс — это обычный инструмент ООП: один тип, несколько реализаций, выбор конкретной реализации происходит в рантайме за счёт полиморфизма и DI.
14 чем отличается expect / actual от интерфейса?


В KMP expect/actual работает на уровне компиляции: в commonMain мы объявляем expect-тип или функцию — это контракт, а для каждой платформы даём actual-реализацию. При сборке для Android/ iOS компилятор просто подставляет нужную реализацию. В рантайме никакого полиморфизма здесь нет — для конкретного таргета существует ровно одна “реальная” версия этого API.


expect/actual помогает вынести платформенно-зависимый код в platform source set, при этом общий код выглядит так, будто он работает с обычными классами/функциями. Интерфейсы же больше про дизайн внутри одной платформы и выбор реализации на уровне DI.


15 Чем отличается интерфейс от абстрактного класса?


Интерфейс я воспринимаю как чистый контракт — он описывает поведение, которое класс должен реализовать. Класс может реализовать много интерфейсов, но не может наследоваться от нескольких классов. Абстрактный класс — это уже “полуготовый” класс: он может содержать состояние, конструктор, общую реализацию методов, но сам не инстанцируется. Я использую интерфейс, когда мне нужна гибкая декомпозиция поведения и возможность миксовать разные “способности”. Абстрактный класс беру тогда, когда есть общее состояние и базовая логика, которую хочу разделить между наследниками в одной иерархии.
16. Зачем явно нужны expect/actual функции, если можно ограничится наследованием и интерфейсами
В KMP можно решать платформенные зависимости двумя путями: через интерфейсы и через expect/actual. Интерфейсы работают на уровне ООП и DI: в commonMain я объявляю интерфейс, а в androidMain/iosMain — разные реализации, которые прокидываю в общий код через конструкторы или DI-контейнер.


expect/actual — это другая ось: это языковая конструкция мультиплатформы. В commonMain я объявляю expect-класс или функцию — это чистый контракт, без реализации. Компилятор заставляет меня в каждом платформенном сорсете дать actual-реализацию с совпадающей сигнатурой и не даст собрать проект, если для какого-то таргета реализация отсутствует. При компиляции под конкретную платформу expect подменяется соответствующим actual, и общий код может вызывать его как обычный класс или top-level функцию, без DI.


Кроме того, expect/actual работает не только с классами, но и с функциями, свойствами и typealias, что позволяет аккуратно заворачивать платформенные типы (Context, NSWhatever) и при этом держать common-код чистым.


17. Общие правила для написания хорощего common в KMP 


никакого платформенного кода, это должа быть идеально чистая архитектура, одинаковость работы на обоих платформах, работаем абстрактно, бизнес логика должна быть отделена от реализации


18. Чем создание класса в kotlin отличаются от java, как наследование отличается


В Kotlin создание классов более компактное: primary-конструктор и свойства объявляются прямо в заголовке, нет new, есть параметры по умолчанию и спец-типы вроде data, object, sealed.


Наследование в Kotlin жёстче по умолчанию: классы и методы final, и чтобы разрешить наследование или override, нужно явно помечать open или abstract. Синтаксис : объединяет extends и implements, у наследников мы вызываем конструктор базового класса прямо в заголовке (class Child : Base("arg")). Интерфейсы в Kotlin могут иметь default-реализации и свойства, а вложенные классы по умолчанию ведут себя как static nested в Java, а для обычных inner-классов нужен модификатор inner.


В Kotlin есть отдельные виды классов, которых нет в Java “из коробки”:
        •        data class — авто-генерация equals/hashCode/toString/copy/componentN.
        •        sealed class / sealed interface — закрытые иерархии.
        •        object — синглтон.
        •        companion object — аналог статических членов.
19. Extension функции во что превращатся в java, в java можно сделать extension
В static метод


                              * Extension-функции в Kotlin разрешаются статически по типу выражения (не виртуальный dispatch как у методов).

                              * На JVM это обычные статические функции, где приёмник — первый параметр.

                              * В Java нет нативных extension-методов, но можно:

                                 * либо просто пользоваться static-утилитами,

                                 * либо вызывать Kotlin-extension’ы как обычные static-методы из сгенерированного XXXKt класса.
В Kotlin extension-функции — это синтаксический сахар: на JVM они компилируются в static-методы, где receiver становится первым параметром. Класс, к которому мы «добавляем» extension, остаётся нетронутым. В Java нативной поддержки extension нет — максимум, мы можем эмулировать их через static-утилиты или вызывать Kotlin-extension’ы как обычные static-методы из FooKt-классов.


20. 5 методов переопределяемые в data class?, как генерятся методы, property в конструткорах, как работает copy(изменится hashcode и equals)
Kotlin автоматически генерирует (на основе свойств primary-конструктора):
        1.        equals(other: Any?): Boolean
        2.        hashCode(): Int
        3.        toString(): String
        4.        componentN(): T (component1, component2, … по числу свойств)
        5.        copy(...)
Всё, что в primary-конструкторе с val/var:
        •        становится property класса (с геттером/сеттером для var);
        •        автоматически участвует в equals, hashCode, toString, copy, componentN.
data class User(
    val name: String
) {
    var age: Int = 0   // НЕ в конструкторе → не участвует в equals/hashCode/copy/componentN
}
Что делает copy:
        •        создаёт новый экземпляр класса того же типа;
        •        копирует значения свойств из primary-конструктора;
        •        позволяет переопределить любые из них аргументами.
equals и hashCode


equals сравнивает структурно все свойства из primary-конструктора по порядку:
u1 == u2  // true, т.к. у обоих name="Anton", age=30
u1 == u3  // false, т.к. age разный
hashCode строится из тех же свойств (как обычно: 31 * result + prop.hashCode):
        •        у u1 и u2 hashCode будет одинаковый;
        •        у u3 — другой, потому что age другой.


Важно понимать мысль:


copy() не меняет саму реализацию equals/hashCode — она одна и та же для всех экземпляров.
Но у нового объекта могут быть другие значения полей, а значит, результат equals() и hashCode() будет другим.


Ещё нюанс: копирование поверхностное:
data class Box(val items: MutableList<String>)


val b1 = Box(mutableListOf("a"))
val b2 = b1.copy()


b1.items === b2.items // true, это один и тот же список
copy копирует ссылку на список, не сам список.
componentN — это операторные методы, которые Kotlin использует для деструктурирования. Когда я пишу val (a, b) = obj, компилятор фактически вызывает obj.component1() и obj.component2(). Data-классы, Pair, Triple, Map.Entry автоматически их имеют. Я сам пишу operator fun componentN, если хочу, чтобы мой класс распаковывался в удобном виде, например в цикле или через val (x, y) = point. В остальном это чистый синтаксический протокол, а не какая-то отдельная “магия”.


21. value class


@JvmInline
value class UserId(val value: Long)
Ограничения:
        •        В primary-конструкторе ровно одно property (val или var, но на практике val).
        •        Нельзя иметь init-блок.
        •        Нельзя иметь других полей с backing field.
        •        Нельзя быть open, sealed, inner; можно реализовывать интерфейсы.
        •        Можно объявлять методы, расширения, companion object и т.д.


То есть это по сути:


«Класс-обёртка вокруг одного значения, без собственного состояния сверх этого значения».


value class в Kotlin — это способ сделать типобезопасную обёртку над одним значением (например, UserId, Email), при этом избежать лишних аллокаций. На JVM это компилируется в обычный final-класс с одним полем и методами, но компилятор Kotlin старается подставлять underlying-тип (например, long) напрямую везде, где это возможно, и использовать класс только там, где нужен референсный тип (nullable, generics, Any).


Это удобно для моделирования доменных типов (ID-шники, value objects) без накладных расходов обычного data-класса, и именно так реализованы, например, unsigned-типы UInt, ULong в стандартной библиотеке.


22. чем отличаются == от ===
В Kotlin разница очень чёткая:
                                    * == - структурное сравнение (по содержимому / по equals)

                                    * === - ссылочное сравнение (тот же самый объект в памяти или нет)
        •        Почти всегда в бизнес-логике — ==:
        •        сравнить модели, строки, числа, data class’ы и т.д.
        •        === — редко:
        •        проверить, что это именно тот же самый объект (кэш, синглтон, ссылка в памяти),
        •        сравнить this/other на identity.
В Kotlin == - это структурное сравнение, оно вызывает equals и null-safe. === - это проверка ссылочного равенства, то есть один и тот же объект или нет.


23. как работают stack и heap в runtime, песочница, процесс, пулл потока(их стеки), heap - GK, stak в heap, где хранится val внутри класса, кеш потоки(atomic, volatile, syncronized)
val / var локальные в функции:
​​fun foo() {
    val x = 10        // примитив → в стеке (или вообще в регистре)
    val user = User() // ссылка user → в стеке, сам User → в heap
}
        •        примитивы (int/long/boolean) — обычно в стеке (или CPU-регистре),
        •        ссылки на объекты — в стеке, объекты — в he
val / var внутри класса:
class User(val name: String, var age: Int)
в heap:
объекты (new User(...), в Kotlin — любые class/data class/object),
        •        массивы (IntArray, Array<String> и т.д.),
        •        строки,
        •        поля объектов (val / var внутри класса),
        •        объекты-обёртки (Integer, Long, UserId как value class в боксе и т.п.).

в stack:
У каждого потока JVM есть свой стек:
        •        стек состоит из фреймов вызовов (stack frame) — один фрейм на каждый вызов метода;
        •        в каждом фрейме лежат:
        •        параметры метода,
        •        локальные переменные,
        •        временные результаты выражений,
        •        ссылки на объекты в heap.


Стек не собирается GC, он живёт пока живёт поток.
Фрейм удаляется, когда метод завершился.


В runtime JVM у нас есть один общий heap и отдельный стек на каждый поток. В heap лежат все объекты, массивы, строки и поля классов (в Kotlin — все val/var property). Локальные переменные и параметры методов хранятся в стек-фреймах каждого потока, а объекты, на которые они ссылаются, находятся в heap. Сборщик мусора анализирует ссылки из статиков, стеков и JNI и очищает неиспользуемые объекты.


Потоки разделяют общий heap, но их стеки независимы. Из-за кешей процессора и reorder’инга без синхронизации один поток может не увидеть обновления другого. Java Memory Model вводит правила happens-before: volatile, synchronized и атомики (AtomicInteger, AtomicReference и т.д.) обеспечивают корректную видимость и атомарность. В Kotlin это всё работает так же, просто синтаксис другой: @Volatile, @Synchronized, kotlinx.atomicfu и т.п.
ОС
└─ Процесс "java"
   ├─ JVM runtime
   │  ├─ Heap (общий для всех потоков)
   │  │   ├─ объекты User, List, String, ...
   │  │   └─ ...
   │  ├─ Metaspace (классы, метаданные)
   │  └─ Native code (JIT, GC, etc.)
   │
   ├─ Поток 1 (Thread-1)
   │   ├─ Stack Thread-1
   │   │   ├─ frame main()
   │   │   ├─ frame foo()
   │   │   └─ локальные переменные, ссылки на объекты в heap
   │   └─ Регистры CPU (значения во время выполнения)
   │
   ├─ Поток 2 (Thread-2)
   │   ├─ Stack Thread-2
   │   └─ ...
   │
   └─ …


volatile делает две вещи:
        1.        Запись в volatile-переменную:
        •        заставляет CPU протолкнуть все записи в память (flush),
        •        сама запись в volatile идёт в память так, что другие ядра увидят её.
        2.        Чтение из volatile-переменной:
        •        заставляет ядро обновить данные из памяти (invalidate кеш),
        •        и после чтения ты видишь последние записи, сделанные до этого.


Уровень Java-пояснения:
@Volatile var x — гарантирует, что если один поток записал в x, то другие потоки при чтении x увидят новое значение (и все операции до этой записи).

24. Что такое happens-before
A happens-before B ⇔ всё, что сделал поток до A, будет видно потоку, который видит B.


Можно думать так:
        •        Это отношение порядка между событиями в разных потоках.
        •        Если A happens-before B, то:
        •        B обязан видеть все изменения памяти, сделанные до A.

happens-before — это формальное правило, которое говорит, когда один поток гарантированно увидит то, что сделал другой.
                                       * volatile, synchronized, Thread.start(), Thread.join() — создают такие связи.

В JMM:
Выход из synchronized(lock) в одном потоке happens-before последующего успешного входа в synchronized(lock) в другом потоке.
Это означает:
        •        всё, что Thread-1 записал в память до выхода из synchronized,
        •        будет видно Thread-2 внутри его synchronized-блока.
25. Процесс зборки и запуска приложения

1. Ты собираешь APK:
   Kotlin → .class → D8/R8 → classes.dex → APK/AAB


2. Установка на устройство:
   - ART может частично прогнать dex2oat (AOT),
   - подготовить базовый нативный код.


3. Первый запуск:
   - ОС создаёт процесс,
   - ART загружает DEX/.oat,
   - часть кода интерпретируется, часть берётся из AOT.


4. Во время работы:
   - JIT собирает профиль: какие методы горячие,
   - компилирует их в нативный код, встраивает инлайны,
   - переключает выполнение с DEX/интерпретатора на оптимизированный нативный код.


5. Позже (зарядка/idle):
   - системный процесс может взять профиль и ещё раз AOT-компилировать аппу, чтобы следующие запуски шли быстрее.

Если прямо в одном предложении
Компилятор (Kotlin + D8/R8):
превращает твой исходный код в DEX-байткод до установки приложения.
JIT в ART во время работы приложения:
наблюдает, какие участки кода реально горячие, и компилирует их «на лету» в нативный машинный код с оптимизациями под реальный сценарий выполнения, чтобы приложение работало быстрее.
Если хочешь, дальше можем углубиться конкретно в оптимизации JIT/ART (inlining, escape analysis, деоптимизация), или наоборот — в то, как корутины/suspend выглядят на уровне DEX/виртуальной машины.
Если собрать в одно:
•        Kotlin compiler / javac / D8 / R8:
        •        работают на dev-машине;
        •        превращают Kotlin/Java код → JVM-байткод → DEX;
        •        делают языковые и общие статические оптимизации.
•        dex2oat / ART AOT compiler:
        •        работают на устройстве:
        •        при установке или в фоновом режиме;
        •        превращают DEX → нативный код с учётом профиля.
•        ART JIT compiler:
        •        работает во время исполнения:
        •        наблюдает за реальными горячими путями,
        •        компилирует их в нативный код,
        •        подстраивается под реальные данные/паттерны.
•        Интерпретатор ART:
        •        выполняет DEX-код там, где ещё нет JIT/AOT,
        •        важен для холодных путей и для начальных фаз.
1. Метод вызывается впервые → выполняется интерпретатором ART по DEX.
2. Счётчик вызовов растёт → метод признаётся hot.
3. JIT компилирует метод в нативный код и записывает в JIT-кэш.
4. Следующие вызовы:
   - вместо интерпретации → прыгать в JIT-compiled версию.
5. Если предположения JIT ломаются (тип меняется и т.д.) → 
   deopt: откат к интерпретатору / менее оптимизированной версии.
То есть:
                                          * Интерпретатор — всегда есть, может выполнить всё, но медленнее.

                                          * JIT — ускоритель для горячих участков, живёт поверх интерпретатора.

26. Coroutine под капотом
условный:
suspend fun example() {
    println("A")
    delay(100)        // suspend #1
    println("B")
    delay(100)        // suspend #2
    println("C")
}
Под капотом выглядит так:
override fun invokeSuspend(result: Any?): Any? {
    when (label) {
        0 -> {
            println("A")
            label = 1
            val r = delay(100, this)
            if (r === COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED
            // если не подвесились:
            println("B")
            label = 2
            val r2 = delay(100, this)
            if (r2 === COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED
            println("C")
            return Unit
        }
        1 -> {
            // сюда попадаем после ПЕРВОГО delay()
            println("B")
            label = 2
            val r2 = delay(100, this)
            if (r2 === COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED
            println("C")
            return Unit
        }
        2 -> {
            // сюда попадаем после ВТОРОГО delay()
            println("C")
            return Unit
        }
    }
}
то есть:
Внутри десугаренной suspend-функции компилятор использует специальный маркер COROUTINE_SUSPENDED. Любая suspend fun превращается в метод вида foo(..., cont: Continuation<T>): Any?, который либо возвращает реальный результат, либо COROUTINE_SUSPENDED. Именно по этому маркеру рантайм понимает, что корутина ушла в приостановку, и потом она будет продолжена через resume.


Состояние корутины хранится в сгенерированном continuation-классе: там есть поле label: Int, которое использует компилятор как номер состояния для state-machine. label = 0 — первый заход, 1, 2, ... — точки возврата после каждой suspend-точки. Чем больше suspend-вызовов внутри, тем больше возможных значений label. На уровне байткода в label ещё зашивают дополнительные флаги (старший бит), но концептуально это просто индекс состояния.


27. Coroutine state machine
State machine (машина состояний) — это способ переписать «линейный» код с suspend в форму:
«одна функция, которая каждый раз, когда её вызывают, смотрит в какое состояние она была в прошлый раз (label) и продолжает с нужного места».
        •        state machine — то, во что компилятор разворачивает suspend fun: класс с label и invokeSuspend, который возвращает либо результат, либо COROUTINE_SUSPENDED.
        •        Continuation — объект, который знает:
        •        какой контекст (CoroutineContext),
        •        как продолжить выполнение (resumeWith).
        •        ContinuationImpl — базовый класс, от которого компилятор генерит конкретные continuation-классы для твоих suspend-функций.
        •        CoroutineContext — иммутабельная мапа: Job, dispatcher, имя, handler’ы и т.п.
        •        Job — жизненный цикл корутины, отмена, иерархия родитель/дети.
        •        Deferred — Job + результат, await() вместо join().
        •        suspendCancellableCoroutine — низкоуровневая точка входа, чтобы обернуть callback-API в suspend, с поддержкой отмены через Job.


28. транзакции при работе с atomic, happens before


Классы Atomic* реализованы на базе volatile и CAS. Каждая операция над атомиком (getAndSet, compareAndSet, incrementAndGet, updateAndGet и т.д.) — это атомарный read-modify-write, линеаризуемый относительно других потоков. С точки зрения Java Memory Model, они ведут себя как volatile-операции: запись в атомик happens-before последующего чтения этого же атомика другим потоком, если тот видит новое значение. Поэтому атомики удобно использовать как мини-транзакции над одним значением и как механизм публикации: мы сначала заполняем объект, затем публикуем его через AtomicReference.set, и любой поток, прочитавший это значение через get, гарантированно увидит все записи, сделанные до публикации.


При этом атомик не решает транзакции над несколькими полями — для этого либо объединяют состояние в один immutable-объект и обновляют его через CAS-цикл, либо используют блокировки.


29. ReentrantLock, AtomicReference, Lock-free алгоритмы


ReentrantLock — это явная взаимная блокировка из java.util.concurrent.locks, аналог synchronized, но с более гибким API: можно делать tryLock, lockInterruptibly, настраивать fairness. Reentrant означает, что один и тот же поток может захватывать lock несколько раз подряд, счётчик захвата увеличивается, и lock реально освобождается только после соответствующего числа unlock.


AtomicReference — это атомарная обёртка над ссылочным типом, построенная на volatile + CAS. Она позволяет делать атомарные read-modify-write операции (compareAndSet, updateAndGet и т.д.) и использовать её как базовый примитив для lock-free алгоритмов и безопасной публикации объекта между потоками.


Lock-free алгоритмы — это структуры и протоколы, которые не используют блокировки (или почти не используют) и опираются на атомики/CAS. Их ключевое свойство — отсутствие блокирующего ожидания одного потока от корректного поведения другого: даже если один поток завис, другие продолжают продвигаться. Классический пример — стек или очередь на AtomicReference, где операции реализованы как CAS-циклы вместо synchronized/ReentrantLock.

Есть три уровня (в теории):
        1.        Obstruction-free — если поток работает один, без конкуренции, он закончит; но другие могут его постоянно “ломать”/мешать в реальности.
        2.        Lock-free — гарантирован прогресс в целом (кто-то да продвинется).
        3.        Wait-free — каждый поток завершит свою операцию за конечное число шагов (самый сильный гарант, очень сложно реализуется).


Стандартные Atomic* дают примитивы, из которых можно строить lock-free структуры (чаще lock-free или obstruction-free, редко wait-free).


29. какие lock есть в syncronized(на функцию, на блок функции еще??)


Lock на конкретный объект:
        •        synchronized(this) { ... }
        •        synchronized(lockObject) { ... }
        •        synchronized(someField) { ... }
        2.        Lock на this для метода:
        •        synchronized fun foo() в Java (@Synchronized в Kotlin на instance-методе)
≈ synchronized(this) { тело }.
        3.        Lock на объект класса (Class):
        •        static synchronized fun в Java,
        •        @Synchronized на функции companion object в Kotlin
≈ synchronized(MyClass.class) { тело }.


При этом тип блокировки один и тот же — intrinsic lock (монитор), просто:
        •        либо монитор объекта,
        •        либо монитор this,
        •        либо монитор MyClass.class.


30. Java memory model(свод правил, принципы обеспечения консистентности), что такое memory model


Java Memory Model:
        •        описывает, как операции с памятью разных потоков могут видеть друг друга;
        •        разрешает компилятору и CPU переставлять инструкции до тех пор, пока:
        •        не нарушаются правила happens-before,
        •        не ломается поведение корректно синхронизированных программ;
        •        вводит примитивы, создающие hb-связи:
        •        synchronized (мониторы);
        •        volatile;
        •        старт/join потоков;
        •        final-поля;
        •        атомики, как надстройка над volatile.


Java Memory Model — это формальное описание того, какие reorder’ы и оптимизации разрешены компилятору/процессору, и при каких условиях записи одного потока гарантированно видны другим. Основной инструмент — отношение happens-before: если A happens-before B, то все эффекты A видны в B. Связи happens-before создают synchronized (enter/exit монитора), операции с volatile-полями, старт/завершение потоков и правила для final-полей. Если программа корректно синхронизирована (нет data race), JMM гарантирует поведение, эквивалентное последовательному выполнению, что позволяет нам мыслить в терминах “как будто всё выполняется по очереди”, несмотря на оптимизации компилятора и out-of-order выполнение на CPU.


31. Разница между ссылкой и указателем


В терминах JVM, reference — это по сути указатель на объект в куче, но сильно ограниченный: язык не даёт доступ к адресу напрямую, запрещает арифметику указателей, а памятью управляет GC. Мы можем только хранить, копировать и сравнивать такие ссылки, а вся низкоуровневая работа с адресами скрыта внутри виртуальной машины.


В классическом C/C++ pointer — это “сырое” значение-адрес, над которым можно делать арифметику, кастовать к разным типам, разыменовывать, и при этом ответственность за корректность и освобождение памяти полностью на программисте. В этом смысле указатель — более низкоуровневый и опасный механизм, а ссылка в managed-языках — высокоуровневая и безопасная абстракция поверх него.


32. Как работает GC на уровне процесса, на уровне Android(OOM killer)
каждое Android-приложение = отдельный Linux-процесс, внутри которого живёт свой экземпляр ART (раньше Dalvik) со своей кучей (heap) и своим GC.
GC никогда не трогает память других процессов — только свой heap.
Жизненный цикл внутри процесса:
                                             1. Ты делаешь new / создаёшь объекты в Kotlin/Java.
                                             2. Эти объекты кладутся в heap.
                                             3. Когда свободного места мало, или есть давление по памяти → запускается GC.
                                             4. GC:

                                                * находит живые объекты (до которых можно добраться по ссылкам),
всё остальное считает мусором,
                                                * освобождает память под мусор,
                                                * в некоторых алгоритмах ещё и уплотняет (перемещает живые объекты, чтобы не было фрагментации).

1.2. GC-roots (откуда начинается обход)
GC не может просто «перебрать всё» — он нужен начальный набор “корней”:
                                                   * локальные переменные и параметры в стеке всех потоков;
                                                   * значения в регистрах CPU, на которые есть ссылки;
                                                   * статические поля (static, top-level val/object);
                                                   * ёссылки из JNI (native-код, который держит Java-объекты через JNI);
                                                   * некоторые служебные структуры VM.
Всё, до чего можно добраться по ссылкам — живое.
Всё остальное — мусор.
1.3. Типичный алгоритм: mark-sweep (+ compaction)
В упрощённой форме (ART / HotSpot — вариации одного и того же):
                                                   1. Mark (пометить):
                                                   * от корней DFS/BFS-обход,
                                                   * всё, до чего добрались → помечаем как live.

                                                      2. Sweep (подмести):
                                                      * проходим по куче,
                                                      * всё непомеченное → свободно, можно использовать для новых объектов.

                                                         3. Compaction (уплотнение) — не всегда, но часто:
                                                         * чтобы не было “дыр” в памяти, живые объекты переносятся в более компактную область;
ссылки на них обновляются (это требует stop-the-world или хитрой concurent-логики).
1.4. Generational GC (молодое/старое поколение)
Наблюдение:
большинство объектов живут недолго (строки, временные коллекции, DTO и т.п.).
Поэтому heap делят на поколения:
                                                            * Young generation (eden + survivor):
                                                            * сюда попадает всё, что ты только что создал;
minor GC: частый, быстрый, чистит только молодое поколение;
                                                            * большинство тупо умерло → легко освободить.

                                                               * Old generation:
                                                               * объекты, пережившие несколько сборок в young → “переезжают” в старшее поколение;
                                                               * major / full GC: реже, дороже, сканирует большой кусок памяти.

ART на Android использует свои схемы (region-based, generational, concurrent mark-sweep, heap compaction и т.п.), но идея такая же:
Маленькие, частые сборки в молодом поколении + более редкие полноразмерные/старшие.
1.5. Stop-the-world и concurrent GC
GC не может просто читать/писать ссылки, пока твой код одновременно их меняет → нужны safepoint’ы или протоколы.
Обычно есть фазы:
                                                                  * Stop-the-world (STW):
                                                                  * все потоки приложения приостанавливаются в “безопасных точках”;
GC спокойно сканирует стеки/регистры, изменяет структуру кучи.

                                                                     * Concurrent фазы:
                                                                     * часть mark/sweep может делаться параллельно с работой приложения;
но всё равно есть короткие STW-паузы (root scan, переустановка ссылок и т.п.).
На Android:
                                                                        * GC старается быть “mostly concurrent”, чтобы паузы UI-треда были короткими;
но если память совсем туго — от пауз не уйти.

3. Уровень Android / Linux: OOM killer, LMK, LMKD
Когда говорят «OOM killer» на Android, обычно имеют в виду две вещи:
                                                                           1. Обычный Linux OOM killer:
                                                                           * когда у всей системы (всех процессов) кончилась память;
                                                                           * ядро выбирает один или несколько процессов → убивает их, чтобы освободить RAM.

                                                                              2. Android Low Memory Killer (LMK / LMKD):
                                                                              * надстройка, которую Android использует проактивно, до того, как всё совсем плохо;
                                                                              * ориентируется на приоритеты процессов (foreground, service, cached, empty и т.д.).

3.1. Как Android решает, кого убить
У каждого процесса есть adj / oom_score — показатель “важности”:
                                                                                 * foreground / видимый:
                                                                                 * активная Activity, сервис, к которому привязан UI;
                                                                                 * максимально защищён от убийства.

                                                                                    * service / perceptible:
                                                                                    * важные сервисы (музыка, навигация и т.п.).

                                                                                       * background / cached / empty:
                                                                                       * процессы без активной Activity,
                                                                                       * давно не использовались,
                                                                                       * можно перезапустить при следующем заходе.

Когда памяти мало:
                                                                                          1. Система пытается освободить всё «мягко»:

                                                                                             * очищает page cache,
                                                                                             * гонит GC в процессах,
                                                                                             * шлёт onTrimMemory(), onLowMemory() в приложения, чтобы они сами чистили кеши.

                                                                                                2. Если этого недостаточно:

                                                                                                   * LMK/LMKD (демон в userspace + хуки в ядре) начинает выбирать и убивать процессы с наихудшим приоритетом:
                                                                                                   * сначала empty/cached;
                                                                                                   * потом background;
                                                                                                   * и только в крайнем случае foreground.

                                                                                                      3. Убийство процесса:

                                                                                                         * ядро посылает сигнал (обычно SIGKILL);
                                                                                                         * процесс моментально умирает:
                                                                                                         * весь его heap,
                                                                                                         * все ресурсы,
                                                                                                         * все потоки → исчезают;
                                                                                                         * никакого finally, onDestroy, catch ты не увидишь.

Следующий заход пользователя в твоё приложение → полный холодный старт.
3.2. Важно: GC vs LMK — разные уровни
                                                                                                            * GC:
                                                                                                            * работает внутри процесса;
                                                                                                            * пытается освободить память в рамках heap’а приложения;
                                                                                                            * максимум → OutOfMemoryError только этому процессу.

                                                                                                               * LMK / OOM-killer:

                                                                                                                  * работает на уровне операционной системы;
                                                                                                                  * смотрит на общую ситуацию по RAM;
                                                                                                                  * убивает целый процесс, чтобы ОС выжила;
                                                                                                                  * твой код это не перехватывает.

И это может происходить параллельно:
                                                                                                                     * твоё приложение живёт, alloc’ит, GC периодически чистит;

                                                                                                                     * в какой-то момент система решает: «мне всё равно мало памяти» → убивает твой процесс, даже если у тебя всё ок по heap.

Внутри Android-приложения памятью управляет ART GC: у каждого процесса есть свой heap, и сборщик мусора периодически сканирует граф ссылок от GC-root’ов (стеки, статические поля, JNI) и удаляет недостижимые объекты, часто с разделением на молодое и старое поколение и с короткими stop-the-world паузами. Если heap упирается в лимит и GC не может освободить достаточно, приложение получает OutOfMemoryError, но процесс как таковой жив.


На уровне всей системы память контролирует Linux/Android. Когда общая RAM заканчивается, включается low memory killer: он смотрит на приоритеты процессов (foreground, background, cached) и начинает убивать наименее важные, полностью завершая процесс — без шанса что-то поймать в коде. GC и OOM-killer работают на разных уровнях: GC чистит мусор внутри одного процесса, а OOM-killer освобождает память, выстрелив в сам процесс целиком.


33. Какие фазы компиляции kotlin кода в KMP в android/ios IAR(платформенно независимый формат)


В KMP компиляция всегда начинается одинаково: фронтенд Kotlin парсит .kt, делает анализ типов, проверяет expect/actual и строит общий Kotlin IR. Далее подключается платформенный backend.


                                                                                                                        * IR — это внутренний язык/формат компилятора Kotlin, на который переводятся .kt перед тем, как стать JVM-байткодом, нативным кодом и т.п.

                                                                                                                        * .klib — это упаковка для Kotlin/Native (iOS и др.), содержащая IR/метаданные/код, которую потом линкуют в .framework/XCFramework.
Для Android используется JVM-backend: из IR генерируется JVM-байткод (.class), затем стандартный Android-пайплайн D8/R8 превращает его в DEX и упаковывает в APK/AAB. Для iOS используется Kotlin/Native backend: из того же IR генерируется Kotlin/Native IR, затем LLVM IR, который через LLVM оптимизируется и превращается в машинный код для arm64/x86_64. Промежуточный артефакт Kotlin/Native — это .klib (Kotlin/Native library), а финальный — .framework/XCFramework, который подключается в Xcode.


То есть KMP строится вокруг единого IR-слоя: общий код компилируется в одну IR-форму, а дальше каждый backend (JVM/Android, Native/iOS) по-своему понижает её до байткода/машинного кода.


34. Какая разница между JVM-компилятором и Kotlin-компилятором?
                                                                                                                           * Если под JVM-компилятором понимать javac, то:
                                                                                                                           * javac: Java → JVM-байткод;
                                                                                                                           * kotlinc: Kotlin → JVM-байткод (плюс ещё IR/Native/JS для других таргетов).
                                                                                                                           * Оба дают .class, но Kotlin-компилятор сам реализует фичи Kotlin (coroutines, data class, inline и т.д.) на уровне байткода.

Если я делаю приложение на Android на Kotlin, какой компилятор работает?
                                                                                                                              * На этапе сборки:
                                                                                                                              * Kotlin-компилятор (kotlinc) компилит .kt → .class;
                                                                                                                              * (плюс javac, если у тебя есть .java).
                                                                                                                              * потом D8/R8 → .dex.

                                                                                                                                 * На устройстве:
                                                                                                                                 * код выполняет ART (интерпретатор + JIT/AOT),
ему уже всё равно, Kotlin это был или Java.

35. Side effects
side effect → это наблюдаемый снаружи результат выполнения кода/функции.
Без side effects программа бесполезна — она ничего не меняет во внешнем мире.
Side effects между потоками строго завязаны на Java Memory Model: чтобы один поток наверняка увидел то, что сделал другой, нужен happens-before (через volatile, synchronized, атомики и т.д.).


Side effect — это любое наблюдаемое изменение состояния вне возвращаемого значения функции: запись в поля объектов, изменение глобальных переменных, I/O (файлы, сеть, БД), логирование, работа с временем, random, синхронизация и т.д. Чистая функция зависит только от аргументов и ничего не меняет – одинаковый вход → одинаковый выход.


Сайд-эффекты усложняют тестирование и reasoning, особенно в многопоточке, потому что порядок операций и Java Memory Model начинают играть ключевую роль. Поэтому в Kotlin/Android обычно стараются отделять «чистое ядро» (pure функции) от “грязной оболочки” (репозитории, network, БД, UI-слой), где side effects сконцентрированы и контролируемы — через корутины, Flow, Compose-side-effects и т.п.


Android
1. Как запускается мобильное приложение(когда в студии жмем плей, когда кликаем на значе аппы)
1. Когда жмёшь Run в Android Studio
1.1. Сборка и установка
По шагам:
                                                                                                                                    1. Gradle собирает APK/AAB:
                                                                                                                                    * Kotlin → .class → .dex;
                                                                                                                                    * ресурсы → resources.arsc;
                                                                                                                                    * всё упаковывается в .apk;
                                                                                                                                    * подписывается debug-ключом.

                                                                                                                                       2. Studio через ADB:
                                                                                                                                       * выполняет adb install (или adb install-multiple для split APK);
                                                                                                                                       * устройство (PackageManager) устанавливает приложение:
                                                                                                                                       * проверка подписи, манифеста;
                                                                                                                                       * разворачивает файлы в /data/app/....

                                                                                                                                          3. Studio после успешной установки выполняет через adb shell команду типа:
am start -n com.example.app/.MainActivity
Всё, дальше процесс точно такой же, как если бы пользователь нажал на иконку:
запуск процесса через Zygote, создание Application, Activity и т.д.
2.1. Launcher генерит Intent
                                                                                                                                             1. На экране home у пользователя есть Launcher (приложение-рабочий стол).

                                                                                                                                             2. Иконка приложения → это Intent с действием ACTION_MAIN + CATEGORY_LAUNCHER на твою LAUNCHER-Activity (обычно MainActivity).

                                                                                                                                             3. При клике:
                                                                                                                                                * Launcher вызывает startActivity(intent) → IPC в ActivityManagerService (AMS).
2.2. AMS решает: нужен ли новый процесс
AMS проверяет:
                                                                                                                                                * Есть ли уже живой процесс для этого пакета?
                                                                                                                                                * Если нет → нужно создать новый процесс.
                                                                                                                                                * Если есть → используем его (hot/warm start, без fork).
________________


3. Создание нового процесса: Zygote → fork
Когда процесса ещё нет (cold start):
                                                                                                                                                1. AMS просит Zygote: «создай новый процесс для com.example.app».
                                                                                                                                                2. Zygote — специальный системный процесс, в котором уже:
                                                                                                                                                * загружен ART,
                                                                                                                                                * загружены базовые системные классы (android.*, часть фреймворка),
                                                                                                                                                * настроено окружение.

                                                                                                                                                   3. Zygote делает fork():
                                                                                                                                                   * создаётся новый Linux-процесс — процесс твоего приложения;
                                                                                                                                                   * он наследует:
                                                                                                                                                   * код ART,
                                                                                                                                                   * загруженные общие классы,
                                                                                                                                                   * настройки среды.

                                                                                                                                                      4. В новом процессе выполняется ActivityThread.main():
                                                                                                                                                      * создаётся главный (UI) поток;
                                                                                                                                                      * запускается Looper / MessageQueue;
                                                                                                                                                      * процесс готов принимать команды от системы.

________________


4. Инициализация приложения внутри процесса
Дальше AMS заставляет новый процесс «поднять» твой код.
4.1. bindApplication → Application
                                                                                                                                                         1. AMS шлёт в процесс сообщение bindApplication (через Binder).
                                                                                                                                                         2. Внутри ActivityThread:
                                                                                                                                                         * загружается твой Application класс;
                                                                                                                                                         * перед этим создаются/инициализируются все ContentProvider’ы (важно, они идут до Application.onCreate()).
                                                                                                                                                         3. Вызывается:
app.attachBaseContext(...)
app.onCreate()
                                                                                                                                                         4. Здесь обычно:
                                                                                                                                                            * инициализируешь DI (Hilt/Koin/Dagger),
                                                                                                                                                            * заводишь логгер, Crashlytics, аналитику и т.д.
________________


5. Создание и запуск 
Activity
 (launcher-экрана)
После Application AMS выполняет startActivity для нужной Activity.
                                                                                                                                                            1. AMS отправляет в процесс команду: «создай MainActivity».
                                                                                                                                                            2. ActivityThread:
                                                                                                                                                            * создаёт экземпляр MainActivity;
                                                                                                                                                            * вызывает последовательно:
activity.attach(...)
activity.onCreate(savedInstanceState)
activity.onStart()
activity.onResume()
                                                                                                                                                            3. В это время:
                                                                                                                                                            * создаётся Window, DecorView,
                                                                                                                                                            * запускается инфлейт layout’а,
                                                                                                                                                            * всё отправляется в SurfaceFlinger для отрисовки на экране.
Пользователь видит первый экран.
Это и есть cold start:
новый процесс + инициализация Application + создание Activity.
6. А если процесс уже жив (горячий старт)
Когда пользователь сворачивает приложение, но система его не убила, сценарий другой:
                                                                                                                                                            * Процесс и heap живут.
                                                                                                                                                            * Application уже создан (onCreate был).
                                                                                                                                                            * При повторном нажатии на иконку:
                                                                                                                                                            1. Launcher → startActivity(intent).
                                                                                                                                                            2. AMS видит, что процесс уже существует.
                                                                                                                                                            3. Варианты:
                                                                                                                                                            * если Activity есть в back stack и не уничтожена → может быть только onRestart / onStart / onResume;
                                                                                                                                                            * если Activity была уничтожена, но процесс жив → новый Activity-инстанс, но без fork-процесса (warm start).

Здесь нет нового fork от Zygote, всё быстрее → это уже warm/hot start, а не cold.
________________


7. Вся цепочка в одном списке
Когда жмёшь Run в Studio:
                                                                                                                                                               1. Gradle:
                                                                                                                                                               * Kotlin/Java → .class → .dex → .apk.
                                                                                                                                                               2. adb install устанавливает APK.
                                                                                                                                                               3. adb shell am start ... отправляет команду AMS, что нужно стартовать Activity.
                                                                                                                                                               4. Дальше → как при клике по иконке (см. ниже).
Когда кликаешь по иконке:
                                                                                                                                                               1. Launcher формирует Intent(ACTION_MAIN, CATEGORY_LAUNCHER) и вызывает startActivity.
                                                                                                                                                               2. AMS проверяет:
                                                                                                                                                               * есть процесс → используем его (warm/hot start);
                                                                                                                                                               * нет процесса → просим Zygote сделать fork() → создаётся новый процесс.
                                                                                                                                                               3. В новом процессе:
                                                                                                                                                               * запускается ActivityThread.main() → UI-поток + Looper.
                                                                                                                                                               * AMS шлёт bindApplication → создаётся Application, onCreate().
                                                                                                                                                               * AMS шлёт команду на создание MainActivity → onCreate/onStart/onResume.
                                                                                                                                                               4. Экран отображается.

2. PackageManager
                                                                                                                                                                  1. PackageManagerService:
                                                                                                                                                                  * распаковывает APK,
                                                                                                                                                                  * читает AndroidManifest.xml,
                                                                                                                                                                  * проверяет подпись, minSdk, targetSdk и т.д.;
                                                                                                                                                                  * регистрирует компоненты приложения в системной БД пакетов.
PackageManager — “реестр приложений и их компонентов” + API для работы с ним.
3. ActivityManager
Ответственен за:
                                                                                                                                                                  * жизненный цикл Activity (стек задач, back stack);
                                                                                                                                                                  * запуск и остановку процессов приложений;
                                                                                                                                                                  * связь с Zygote (fork новых процессов);
                                                                                                                                                                  * управление памятью: приоритеты процессов, взаимодействие с LMK;
                                                                                                                                                                  * управление Service’ами, BroadcastReceiver’ами.
Под капотом:
                                                                                                                                                                  1. Intent попадает в ActivityManagerService.
                                                                                                                                                                  2. AMS:

                                                                                                                                                                     * решает, какой Activity его должен обработать (по манифесту);
                                                                                                                                                                     * смотрит, есть ли уже нужный процесс для этого пакета:
                                                                                                                                                                     * нет → просит Zygote создать процесс;
                                                                                                                                                                     * есть → использует его.
                                                                                                                                                                     3. AMS отправляет в процесс команды:
                                                                                                                                                                     * bindApplication → создать Application;
                                                                                                                                                                     * launchActivity → создать/вызвать Activity (onCreate/onStart/onResume).
Объект ActivityManager в твоём коде – это клиент к AMS (через Binder).
4. ActivityThread
Что это
ActivityThread – это НЕ поток, а класс внутри твоего процесса, который:
                                                                                                                                                                     * живёт в главном (UI) потоке приложения;
                                                                                                                                                                     * управляет объектами Activity, Service, ContentProvider;
                                                                                                                                                                     * принимает сообщения от ActivityManagerService и вызывает нужные колбэки (onCreate, onStart, onResume, onPause, onDestroy и т.д.).

Ты его напрямую не используешь, но он есть почти в каждом stacktrace.
Как работает
Когда Zygote форкает новый процесс для твоего приложения:
                                                                                                                                                                        1. В новом процессе вызывается ActivityThread.main():
                                                                                                                                                                        * создаётся главный поток (UI),
                                                                                                                                                                        * запускается Looper и MessageQueue,
                                                                                                                                                                        * процесс готов принимать IPC-команды.

                                                                                                                                                                           2. Когда AMS шлёт команду bindApplication:
                                                                                                                                                                           * ActivityThread создаёт Application,
                                                                                                                                                                           * вызывает onCreate().

                                                                                                                                                                              3. Когда AMS шлёт команду launchActivity:
                                                                                                                                                                              * ActivityThread:

                                                                                                                                                                                 * создаёт Activity объект,
                                                                                                                                                                                 * вызывает у него: attach, onCreate, onStart, onResume,
                                                                                                                                                                                 * управляет взаимодействием с WindowManager и отрисовкой.
Проще:
ActivityThread — “дирижёр внутри процесса приложения”. Он сидит в главном потоке, получает команды от системы и дергает все твои lifecycle-методы.


5. DecorView
                                                                                                                                                                                 * именно DecorView передаётся в WindowManager → получает Surface для рисования;
                                                                                                                                                                                 * он оборачивает твой контент системным оформлением:
                                                                                                                                                                                 * бар заголовка,
                                                                                                                                                                                 * статус-бар (legacy),
                                                                                                                                                                                 * навигацию, inset’ы и т.д.
DecorView — это “верхняя рамка окна”, внутри которой лежит твой layout. Всё, что рисует Activity, живёт внутри DecorView.


6. SurfaceFlinger
SurfaceFlinger — это “глобальный художник системы”, который собирает картинку со всех приложений и отрисовывает итоговый кадр на дисплей.


7. Чем SurfaceFlinger отличается от window
                                                                                                                                                                                 * Window — логическое окно твоего приложения, живёт в процессе приложения. Это абстракция UI: рамка + DecorView + флаги, анимации, инпут.

                                                                                                                                                                                 * SurfaceFlinger — системный композитор картинок, живёт в отдельном системном процессе. Он вообще не знает про Activity, Window, View – ему приносят готовые буферы (Surface’ы), он их склеивает и показывает на экране.
Activity
  └─ Window (PhoneWindow)
       └─ DecorView
            └─ твой layout


8. какие есть пермишены(которые надо запрашивать и которые не надо)
В Android все разрешения делятся на несколько типов.
Normal — типа INTERNET, ACCESS_NETWORK_STATE: их достаточно объявить в манифесте, пользователь не видит отдельного диалога.
Dangerous — доступ к контактам, камере, локации, микрофону, медиа-файлам, SMS и т.д.: их нужно и объявить в манифесте, и запрашивать в рантайме через requestPermissions, начиная с Android 6.
Есть special permissions, которые запрашиваются через отдельные экраны настроек (SYSTEM_ALERT_WINDOW, MANAGE_EXTERNAL_STORAGE, REQUEST_IGNORE_BATTERY_OPTIMIZATIONS и т.д.).
И есть signature/system-пермишены — они доступны только системным приложениям или тем, кто подписан тем же ключом, и обычное приложение их получить не может.


9. Способоы регистрации ресивера


Есть два способа зарегистрировать BroadcastReceiver: статически в манифесте и динамически через registerReceiver в коде.
Receiver из манифеста может быть вызван даже если процесс ещё не запущен — AMS поднимет процесс. 
Но с Android 8+ манифестные ресиверы сильно ограничены для implicit broadcast’ов, чтобы не будить приложения слишком часто. Поэтому многие частые события (сеть, экран, время, батарея и т.п.) нужно слушать только через динамический receiver в Activity/Service/Application.
Напротив, такие события, как BOOT_COMPLETED, PACKAGE_ADDED или SMS_RECEIVED, имеет смысл и можно объявлять в манифесте — они должны разбудить процесс, даже если приложение ещё не запускалось.


сть целый ряд системных интентов, которые по документации нельзя получать через manifest-declared receivers вообще. Классические примеры — ACTION_BATTERY_CHANGED (состояние батареи), ACTION_TIME_TICK (тик каждую минуту), события экрана вроде ACTION_SCREEN_ON / OFF / USER_PRESENT. Для них нужно использовать только динамическую регистрацию через Context.registerReceiver(), иначе onReceive просто никогда не вызовется.
Плюс, начиная с Android 8, большинство частых implicit broadcast’ов, объявленных в манифесте, система игнорирует — их тоже по сути нужно ловить только динамически или через новые callback API.
10. Как диагностировать проблемы с производительность(профайлер, запросы нет, trace, view(onMeasure, onDraw, onLayout), compose(рекомпозиция))
Сначала фиксируем симптом: лаги UI, долгий запуск, сеть, память, батарея.
Потом подключаем соответствующий инструмент:
                                                                                                                                                                                    * CPU Profiler + System Trace — чтобы увидеть, какие методы грузят main thread и где тратится время (включая onMeasure/onLayout/onDraw и Compose-компоненты).
                                                                                                                                                                                    * Layout Inspector — чтобы посмотреть глубину иерархии View, рекомпозиции в Compose.
                                                                                                                                                                                    * Network Profiler — чтобы измерить реальные задержки по сети и время запросов.
                                                                                                                                                                                    * Memory Profiler — чтобы искать утечки и лишние аллокации, которые вызывают частый GC и лаги.
                                                                                                                                                                                    * StrictMode — чтобы поймать диск/сеть/БД на main thread.
Для View-сценариев я проверяю, нет ли тяжёлых операций и аллокаций в onMeasure/onLayout/onDraw. Для Compose — смотрю количество рекомпозиций, где хранятся State, использую remember/derivedStateOf и дроблю composable, чтобы локализовать перерисовку.


11. onMeasure(вычисляет размеры), onDraw(отрисовывает в зависимости от Hz), onLayout(размещает элементы)


VSync / Choreographer
  ↓
ViewRootImpl.performTraversals():
  1) performMeasure()
      → root.onMeasure(...)
         → children.onMeasure(...)


  2) performLayout()
      → root.onLayout(...)
         → children.onLayout(...)


  3) performDraw()
      → root.draw()
         → root.onDraw(...)
         → children.draw()
             → children.onDraw(...)

связь с requestLayout() и invalidate()
                                                                                                                                                                                    * requestLayout():
                                                                                                                                                                                    * говорит: “мой размер/позиция поменялись, нужно пере-мерять и пере-расставить”;
                                                                                                                                                                                    * триггерит: measure → layout → draw.
                                                                                                                                                                                    * invalidate():
                                                                                                                                                                                    * говорит: “размер/позиция норм, но меняется картинка, перерисуй”;
                                                                                                                                                                                    * триггерит: draw (без полного measure/layout).
onMeasure - вычислить желаемые размеры View (ширину и высоту) на основании
                                                                                                                                                                                    * ограничений от родителя,
                                                                                                                                                                                    * собственного содержимого (текст, картинка, children).
Вызывается:
                                                                                                                                                                                    * при первом показе view;
                                                                                                                                                                                    * при каждом вызове requestLayout() на этом view или любом его родителе/предке;
                                                                                                                                                                                    * при изменении:
                                                                                                                                                                                    * ориентации,
                                                                                                                                                                                    * размера окна,
                                                                                                                                                                                    * параметров LayoutParams,
                                                                                                                                                                                    * содержимого, влияющего на размер (например, текст).

                                                                                                                                                                                       * родитель решает, какие ограничения по размеру дать ребёнку → упаковывает их в два int’а: widthMeasureSpec и heightMeasureSpec(внутри mode(EXACTLY, AT_MOST, UNSPECIFIED) — режим измерения и size — доступный размер в пикселях);
                                                                                                                                                                                       * ребёнок в onMeasure():
                                                                                                                                                                                       * смотрит, какие пришли ограничения;
                                                                                                                                                                                       * выбирает нужный размер;
                                                                                                                                                                                       * вызывает setMeasuredDimension(width, height).
onLayout() где именно расположить детей? Задача - для ViewGroup — разложить children по координатам внутри себя.
 вызывается:
                                                                                                                                                                                       * после onMeasure, в layout-проходе:
                                                                                                                                                                                       * для каждого View:
                                                                                                                                                                                       * но реально что-то делает только ViewGroup, у обычного View он почти пустой.
ViewRootImpl.performTraversals():
    ...
    layout(root, 0, 0, rootWidth, rootHeight)
        → root.onLayout(...)
            → child.layout(...)
                → child.onLayout(...)
                    → …
                                                                                                                                                                                       * Вызов child.layout(l, t, r, b):
                                                                                                                                                                                       * задаёт координаты ребёнка относительно родителя;
                                                                                                                                                                                       * внутри вызывает child.onLayout(...)
Параметры:
                                                                                                                                                                                       * changed: Boolean - true, если размер или позиция этого View изменились с прошлого раза(можно использовать, чтобы не перекладывать детей если размер тот же)
                                                                                                                                                                                       * l, t, r, b (left, top, right, bottom) - координаты ТЕКУЩЕГО View относительно его родителя.

onDraw - задача: нарисовать содержимое View на предоставленном Canvas.
                                                                                                                                                                                          * После measure и layout, в фазе draw.
                                                                                                                                                                                          * Каждый раз, когда View нужно перерисовать:
                                                                                                                                                                                          * при первом появлении;
                                                                                                                                                                                          * после invalidate() или postInvalidate() (от тебя);
                                                                                                                                                                                          * при анимациях/скролле;
                                                                                                                                                                                          * когда родитель считает, что его нужно перерисовать.
ViewRootImpl.draw():
    → root.draw(canvas)
        → root.onDraw(canvas)
        → для ViewGroup: drawChild(child, canvas, ...)
            → child.draw(canvas)
               → child.onDraw(canvas)
12. lenear vs constraint
LinearLayout очень прост и дешев, но когда макет становится сложным, он приводит к глубокой иерархии — несколько уровней вложенных Linear/RelativeLayout, что увеличивает стоимость measure/layout и усложняет поддержку. ConstraintLayout позволяет выстроить тот же UI в одной плоской иерархии: все элементы в одном контейнере, а их положение описывается constraint’ами. За счёт этого меньше вложенностей, меньше проходов по дереву, проще адаптивная разметка и удобнее редактировать в Layout Editor. При этом для очень простых случаев LinearLayout по-прежнему оправдан: он проще и достаточно эффективен.


13. передача данных между activity
                                                                                                                                                                                          1. Intent + extras (классика)
                                                                                                                                                                                          * Intent — “конверт” + Bundle с дополнительными данными (extras);
                                                                                                                                                                                          * данные сериализуются в Bundle, могут пережить kill/restart Activity/процесса.
2. Bundle, типы данных, Parcelable vs Serializable
Bundle — это по сути map “String → значение” + сериализация:
                                                                                                                                                                                          * умеет складывать примитивы: Int, Long, Boolean, Float, Double;
                                                                                                                                                                                          * String, CharSequence, String[], CharSequence[];
                                                                                                                                                                                          * массивы примитивов;
                                                                                                                                                                                          * объекты, реализующие Parcelable или Serializable;
                                                                                                                                                                                          * списки тех же типов (ArrayList<Parcelable>, и т.п.).
Всё, что кладёшь в intent.putExtra, по факту идёт в Bundle.
Serializable - Маркерный интерфейс – нет методов.
                                                                                                                                                                                          * Работает через рефлексию:
                                                                                                                                                                                          * JVM/Android-рантайм сам обходит поля класса,
                                                                                                                                                                                          * пишет/читает их в поток байтов.
                                                                                                                                                                                          * Используется в Java SE/EE, может сериализовать объекты:
                                                                                                                                                                                          * в файл,
                                                                                                                                                                                          * по сети,
                                                                                                                                                                                          * в память и т.д.
Parcelable - Заточен под межпроцессное взаимодействие (IPC) в Android:
                                                                                                                                                                                          * Binder,
                                                                                                                                                                                          * Intent extras,
                                                                                                                                                                                          * Bundle, SavedState и т.д.
                                                                                                                                                                                          * Работает через ручную/сгенерированную(Gradle-плагин за тебя сгенерит) запись в Parcel:
                                                                                                                                                                                          * writeToParcel(Parcel),
                                                                                                                                                                                          * CREATOR.createFromParcel(Parcel).
3. Передача данных назад: результат Activity
3.1. Старый способ: startActivityForResult (deprecated, но знать надо)
3.2. Новый способ: Activity Result API
private val pickUserLauncher = registerForActivityResult(
    ActivityResultContracts.StartActivityForResult()
) { result ->
    if (result.resultCode == Activity.RESULT_OK) {
        val data = result.data
        val userId = data?.getIntExtra("user_id", -1)
    }}
fun openPicker() {
    val intent = Intent(this, PickUserActivity::class.java)
    pickUserLauncher.launch(intent)
}


В PickUserActivity всё то же: setResult() + finish().


Плюсы Activity Result API:
        •        нет ручного requestCode;
        •        учитывает lifecycle (автоматически рехук после конфиг-изменений);
        •        легче читать и тестировать.


4. Что делать с большими объектами
Intent/Bundle не предназначены для гигантских данных (мегабайты JSON, битмапы и т.д.). 
Возможные варианты:
        1.        ID вместо “толстого” объекта
        •        В Intent передаёшь идентификатор (например, user_id).
        •        В новой Activity загружаешь данные:
        •        из БД (Room),
        •        из репозитория/сети/кеша.
        2.        Shared ViewModel (Navigation/Fragment’ы) — если у тебя одна Activity и несколько Fragment’ов, но это уже другой вопрос.
        3.        Singleton/DI-контейнер/Repository:
        •        держишь данные в слое моделей (репозиторий),
        •        Activity только берут из него по ключу.
        •        НО: нужно учитывать, что процесс могут убить → строки состояния всё равно должны уметь восстановиться без него.
        4.        Файл / кеш / БД:
        •        кладёшь большие данные туда,
        •        в Intent передаёшь путь/ключ.


Основной способ передачи данных между Activity — через Intent и extras (Bundle). В первой Activity мы создаём Intent, кладём туда примитивы, строки или объекты, реализующие Parcelable (предпочтительно) или Serializable, и вызываем startActivity. Во второй Activity читаем данные из intent.extras. Для возврата результата используется Activity Result API: мы регистрируем ActivityResultLauncher, запускаем вторую Activity и в ней через setResult() + finish() возвращаем Intent с нужными данными.


При этом важно понимать, что Intent/Bundle не предназначены для очень больших объектов, поэтому в реальных приложениях обычно передают идентификаторы, а данные подгружают из репозитория/БД/кеша. Для сложных моделей в extras используют Parcelable (@Parcelize), потому что он быстрее и эффективнее, чем Serializable, и это стандартный формат сериализации данных для Android IPC.


14. onConfiguratinChanges, как хэндлить, как ViewModel переживает уничтожение activity(ViewModelStore, Provider)


Configuration — это состояние устройства/окружения, которое влияет на ресурсы и UI, например:
        •        ориентация (portrait/landscape),
        •        размер и плотность экрана,
        •        язык/локаль,
        •        night mode (day/night),
        •        клавиатура подключена/нет,
        •        режим multi-window и т.п.
Когда что-то из этого меняется → configuration change.
<activity
    android:name=".MainActivity"
    android:configChanges="orientation|screenSize|keyboardHidden" />
Теперь при, например, повороте экрана:
                                                                                                                                                                                          * Activity НЕ уничтожается,
                                                                                                                                                                                          * вместо этого в ней вызывается:
override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    // здесь ты сам должен:
    // - перестроить layout
    // - подстроить ресурсы / размеры и т.п.
}


2. Как ViewModel переживает уничтожение Activity


Activity (ViewModelStoreOwner) // интерфейс, который умеет дать ViewModelStore.
   └─ ViewModelStore// это по сути Map<String, ViewModel>
        ├─ "MyViewModel" → экземпляр MyViewModel
        ├─ "AnotherVM"  → ...
        └─ ...

val vm = ViewModelProvider(this)[MyViewModel::class.java]
Что происходит:
        1.        this = ViewModelStoreOwner (Activity/Fragment).
        2.        ViewModelProvider берёт у него ViewModelStore.
        3.        Внутри ViewModelStore ищет по ключу "com.example.MyViewModel":
        •        если есть → возвращает уже существующий экземпляр (тот же самый VM, что был до поворота);
        •        если нет → вызывает ViewModelProvider.Factory и создаёт MyViewModel, кладёт в store.
                                                                                                                                                                                          * Activity уничтожается, но:
                                                                                                                                                                                          * система сохраняет её ViewModelStore в неком “non-config” хранилище (раньше это были onRetainNonConfigurationInstance() и retained-фрагменты; сейчас под капотом похожий механизм).
                                                                                                                                                                                          * флаг activity.isChangingConfigurations == true.
При конфигурационных изменениях (ориентация, тема, язык) система по умолчанию уничтожает Activity и создаёт её заново. Это позволяет подгрузить правильные ресурсы (layout-land, values-night и т.д.). Мы можем перехватывать изменения через onConfigurationChanged, но делать это стоит только в спец. кейсах (игры, камеры, видео-плееры), иначе теряем часть автоматики.


Сейчас Activity сама реализует механизм сохранения ViewModelStore через non-configuration state. Внутри ComponentActivity есть ViewModelStore, и в момент уничтожения Activity по причине конфигурационного изменения система вызывает onRetainNonConfigurationInstance(). Activity возвращает объект, внутри которого лежит ViewModelStore. При создании новой Activity после поворота она вытаскивает этот объект через getLastNonConfigurationInstance() и восстанавливает ViewModelStore. Поэтому ViewModelProvider находит уже существующую ViewModel и отдаёт тот же экземпляр. Если же Activity уничтожается окончательно, non-config state не сохраняется, ViewModelStore очищается и все ViewModel получают onCleared().


15. CleanArchitecture, в MVVM, MVI, когда допустимо избаваиться от UseCase, от Repository


[ UI (Activity/Fragment/Compose, ViewModel) ]
                ↓
[ Domain: UseCases, Entities ]
                ↓
[ Data: Repositories ]
                ↓
[ Sources: API, DB, Cache, ... ]


        MVVM:
        •        View ↔ ViewModel ↔ UseCase ↔ Repository
        MVI:
        •        View → Intent → (UseCase/Interactor) → new State → View
        •        но уровни те же: Presentation / Domain / Data.


Идея Clean Architecture:
        •        UI ничего не знает о деталях хранения данных (Retrofit, Room и т.д.).
        •        Domain ничего не знает о фреймворках:
        •        только интерфейсы, типы, бизнес-логика.
        •        Data-слой адаптирует внешние штуки под интерфейсы domain’а.


В классическом варианте Clean Architecture с MVVM/MVI у нас есть Presentation → Domain (UseCases) → Data (Repositories). UseCase описывает конкретный бизнес-сценарий, а Repository скрывает источники данных (API, DB, кеш) и преобразует их к доменным моделям.


В реальных Android-проектах UseCase имеет смысл, когда есть реальная бизнес-логика: несколько шагов, ветвления, комбинирование нескольких репозиториев. Если UseCase просто “проксирует” вызов repo.getX(), то его существование сомнительно — в таких случаях я обычно упрощаю схему до ViewModel → Repository.
Repository же я стараюсь сохранять дольше, потому что это хороший слой-адаптер между доменом и конкретными технологиями (Retrofit, Room). Отказаться от Repository можно в очень простых фичах, где ViewModel прямо использует Api/Dao, но это уже осознанный компромисс — мы понимаем, что жертвуем чистотой архитектуры ради скорости и простоты.


То есть для меня важна не “религиозная” Clean Architecture, а то, чтобы сложность архитектуры соответствовала сложности домена: чем больше бизнес-правил и переиспользуемых данных, тем более оправданны UseCases и Repositories. В маленьких, изолированных фичах допускаю упрощённые схемы.
16. ForegroundService, как работают, условия
Обычный Service: 
                                                                                                                                                                                          * работает в фоне без UI,
                                                                                                                                                                                          * система может его убить “по настроению”, если мало памяти,
                                                                                                                                                                                          * пользователь может вообще не знать, что он что-то делает.
Foreground Service:
Это сервис, который обязан показывать постоянное уведомление и считается для системы “что-то важное для пользователя прямо сейчас”.


Запуск:

в манифесте регистрируется и в коде
val intent = Intent(this, MyForegroundService::class.java)
ContextCompat.startForegroundService(this, intent)
Почему не startService?
С Android 8+ из background ты не можешь просто стартануть обычный сервис — нужно запускать foreground-сервис, который быстро перейдёт в foreground с нотификацией.


Внутри сервиса:

class MyForegroundService : Service() {


    override fun onCreate() {
        super.onCreate()
        // инициализация
    }


    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // 1. Создаём Notification
        val notification = buildForegroundNotification()
        // 2. Переводим сервис в foreground-режим
        startForeground(NOTIFICATION_ID, notification)
        // 3. Запускаем свою работу в фоне (поток/корутина)
        startWork()
        // что вернуть:
        return START_STICKY
    }


    override fun onBind(intent: Intent?): IBinder? = null


    override fun onDestroy() {
        super.onDestroy()
        // очистка ресурсов
    }
}


Критично:
                                                                                                                                                                                          * После startForegroundService() система ждёт, что в течение ~5 секунд сервис вызовет startForeground(...).
Иначе → ANR и сервис принудительно стопнут.
2.3. Уведомление
ForegroundService обязан:
                                                                                                                                                                                             * создать NotificationChannel (API 26+),
                                                                                                                                                                                             * показать уведомление, пока идёт работа.
Пример:
private fun buildForegroundNotification(): Notification {
    val channelId = "my_foreground_channel"


    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val channel = NotificationChannel(
            channelId,
            "App work",
            NotificationManager.IMPORTANCE_LOW
        )
        getSystemService(NotificationManager::class.java)
            .createNotificationChannel(channel)
    }


    return NotificationCompat.Builder(this, channelId)
        .setContentTitle("Таймер идёт")
        .setContentText("До конца раунда: 02:15")
        .setSmallIcon(R.drawable.ic_timer)
        .setOngoing(true)
        .build()
}


3. Условия и ограничения (важные нюансы)
На современных Android есть жёсткие ограничения:
3.1. Должен быть “user-visible” work
ForegroundService нельзя использовать для:
                                                                                                                                                                                             * тихой периодической синхронизации;
                                                                                                                                                                                             * фоновых задач “на всякий случай”.
Для этого — WorkManager, JobScheduler, AlarmManager.
ForegroundService — только когда:
                                                                                                                                                                                             * пользователь явно запустил действие,
                                                                                                                                                                                             * он ожидает результат прямо сейчас,
                                                                                                                                                                                             * и логично, что есть постоянное уведомление.
3.2. Запуск из background
                                                                                                                                                                                             * Если твое приложение в фоне, ты не можешь просто вызвать startService():
                                                                                                                                                                                             * будет IllegalStateException (“app is in background”).

                                                                                                                                                                                                * Нужно:
                                                                                                                                                                                                * либо приложение в foreground (Activity на экране),
                                                                                                                                                                                                * либо использовать startForegroundService(), и быстро вызвать startForeground().
НЕ использовать:
                                                                                                                                                                                                * периодический sync (лог, аналитика, бэкапы на сервер) → WorkManager;
                                                                                                                                                                                                * разовые задачи “сделать что-то через 15 минут” → WorkManager/AlarmManager;
                                                                                                                                                                                                * вообще всё, где пользователю пофиг и уведомление будет бесить.
ForegroundService — это обычный сервис, который выполняет важную для пользователя работу и обязан показывать постоянное уведомление. Он получает более высокий приоритет у системы, поэтому его сложнее убить по памяти. Запускается через startForegroundService, а внутри onStartCommand в течение нескольких секунд нужно вызвать startForeground(id, notification) с реальным Notification, иначе система вызовет ANR и остановит сервис.
Использовать foreground-сервис стоит для долгих, “видимых” задач — музыка, трекинг локации, запись, активная загрузка. Для тихих фоновых задач сейчас рекомендуют WorkManager и JobScheduler, потому что из background запуск обычных сервисов сильно ограничен.
17 Service vs ForegroundService

Обычный Service — невидимый фон, который система может спокойно убить. ForegroundService — это сервис, который обязан показать постоянное уведомление и считается системой как “важная, видимая пользователю работа”. Его запускают через startForegroundService(), и внутри за несколько секунд нужно вызвать startForeground(id, notification). Такой сервис получает более высокий приоритет и хуже убивается, поэтому его используют для длинных, важных задач вроде музыки, навигатора или записи, а не для тихих фоновых задач, которые сейчас должны идти через WorkManager.


18. JobScheduler vs WorkManager


JobScheduler — системный сервис (API 21+), который позволяет сказать системе:


“Выполни вот этот JobService при таких-то условиях (Wi-Fi, зарядка, не в Doze и т.д.), когда посчитаешь нужным”.


То есть:
        •        ты описываешь задачу и constraints (ограничения),
        •        ОС сама решает когда её выполнить с учётом:
        •        Doze,
        •        App Standby,
        •        экономии батареи,
        •        нагрузки.
1.3. Какие есть условия/constraints


Через JobInfo.Builder:
        •        setRequiredNetworkType(...):
        •        NONE, ANY, UNMETERED (Wi-Fi), NOT_ROAMING, CELLULAR.
        •        setRequiresCharging(true) — только на зарядке.
        •        setRequiresDeviceIdle(true) — пока устройство в idle (Doze / не трогают).
        •        setRequiresBatteryNotLow(true) — не при низком заряде.
        •        setRequiresStorageNotLow(true) — не при забитой памяти.
        •        Время:
        •        setMinimumLatency(millis) — “не раньше, чем…”.
        •        setOverrideDeadline(millis) — “но не позже, чем…”.
        •        setPeriodic(intervalMillis) — периодическая задача (минимум ~15 минут).


1.4. Важные моменты
        •        Не гарантирует точное время.
Это “примерно тогда, когда удобно системе”.
        •        Job может быть:
        •        отложен (Doze, нет Wi-Fi, нет зарядки),
        •        сброшен (ребут, обновление и т.д.),
        •        перезапущен, если ты вернул true в onStopJob.
        •        Работает только с JobService (нужен отдельный компонент в манифесте).
        •        Только API 21+ 
Когда использовать напрямую:
        •        ты пишешь системную штуку/SDK или что-то, что должно работать без Jetpack;
        •        тебе нужен полный контроль над JobService, специфические фичи JobScheduler’а;




WorkManager — библиотека Jetpack для отложенных, гарантированных задач:


“Сделай вот эту работу, когда будут выполнены условия (сеть, зарядка и т.д.).
Даже если приложение будет убито / перезапущено.”


Ключевые характеристики:
        •        Гарантированное выполнение (насколько позволит система):
        •        задача сохраняется в внутреннюю БД (Room-подобную),
        •        после ребута/килла процесса WorkManager подхватывает её заново.
        •        Учитывает все ограничения платформы:
        •        внутри использует:
        •        на API 23+ → JobScheduler,
        •        на <23 → AlarmManager + BroadcastReceiver + собственный механизм.
        •        Не для точных таймеров (как и JobScheduler), а для deferrable work:
        •        sync, upload логов, бэкапы, cleanup.
                                                                                                                                                                                                * OneTimeWorkRequest — одноразовая задача.
                                                                                                                                                                                                * PeriodicWorkRequest — периодическая:
                                                                                                                                                                                                * минимум ~15 минут интервал;
                                                                                                                                                                                                * система сама решает, когда точно запускать (обычно батчит).
Можно ещё:
                                                                                                                                                                                                * уникальная работа:
                                                                                                                                                                                                * enqueueUniqueWork(name, ExistingWorkPolicy, workRequest) — не плодить дубликаты.
                                                                                                                                                                                                * цепочки:
                                                                                                                                                                                                * workA.then(workB).then(workC) — последовательная or параллельная композиция.
2.5. Важные фишки WorkManager
                                                                                                                                                                                                * Переживает kill/process death/ребут:
                                                                                                                                                                                                * всё описано в БД;
                                                                                                                                                                                                * при старте процесса WorkManager смотрит “что там надо доделать”.
                                                                                                                                                                                                * Единый API для всех версий Android:
                                                                                                                                                                                                * на новых → JobScheduler,
                                                                                                                                                                                                * на старых → AlarmManager/handlers.
                                                                                                                                                                                                * Retry и backoff из коробки:
                                                                                                                                                                                                * можно указать стратегию повторов, delay, exponential backoff.
                                                                                                                                                                                                * Поддержка foreground work (с нотификацией):
                                                                                                                                                                                                * setForegroundAsync() внутри Worker.

WorkManager — это высокоуровневая библиотека для отложенных, гарантированных фоновых задач. Он хранит задания в своей БД, переживает убийство процесса и ребут, и под капотом использует подходящий механизм: JobScheduler на новых версиях, AlarmManager/другие fallback’и на старых. Мы описываем только Worker и constraints, а всё остальное за нас делает библиотека.


JobScheduler — это системный сервис, который напрямую планирует выполнение JobService при определённых условиях (сеть, зарядка, idle) и учитывает Doze/App Standby. Он не даёт точного времени запуска, а только “не раньше чем / не позже чем, при таких-то условиях”. Для прикладных задач и особенно кросс-версионной поддержки обычно используют WorkManager как более удобную и надёжную обёртку.


Выбор простой: если нужна надёжная, отложенная фоновая работа, которая должна “дожить до конца” даже после перезапуска — беру WorkManager. Если пишу что-то ближе к системному уровню и хочу напрямую работать с JobScheduler — использую его API.


18. Какие android компоненты нарушают SingleResponsibility(Context, Application, Все компоненты, где есть контекст, Service, ContextProvider, Fragment, View?)
Если строго смотреть через призму Single Responsibility, почти все базовые Android-компоненты SRP нарушают:
— Context — это “мешок” из доступа к ресурсам, системным сервисам, файлам, запуску Activity/Service и т.д.
— Application, Activity, Fragment, Service, ContentProvider — это по сути “god-objects”, которым фреймворк навесил сразу кучу обязанностей: lifecycle, UI, навигация, IPC, доступ к данным и т.д.


Но это нормально для фреймворка: он даёт нам большие компоненты. Наша задача — не усугублять нарушение SRP своим кодом:
— держать Activity/Fragment/Service максимально “тонкими”;
— вынести бизнес-логику в ViewModel/UseCase/Repository;
— не складывать всё в Application и Context.


То есть SRP мы соблюдаем на уровне своих классов и слоёв архитектуры, а не пытаемся “чинить” базовые компоненты фреймворка.


19. Нотификации, Notification.Builder, NotificationManager, надо сделать конструктор для View, анимации в Notification
ЖЦ уведомлений:

Твой процесс
  ↓
Notification.Builder → Notification
  ↓
NotificationManager.notify(id, notification)
  ↓
Системный UI (StatusBar / NotificationShade) показывает уведомление


Важно: рендерит уведомление НЕ твой процесс, а системный (SystemUI).
Ты ему отправляешь “описание” (Notification + RemoteViews), а он уже рисует.
                                                                                                                                                                                                   * На API 26+ нужно создать NotificationChannel, иначе уведомление может не показаться.
                                                                                                                                                                                                   * Для ForegroundService — этот же Notification пойдёт в startForeground(id, notification).
NotificationManager
Это системный сервис, через который ты:
                                                                                                                                                                                                   * показываешь нотификацию,
                                                                                                                                                                                                   * обновляешь её,
                                                                                                                                                                                                   * отменяешь.
Если нужно своё оформление уведомления (не только заголовок/текст/иконка), используется RemoteViews
                                                                                                                                                                                                   * R.layout.notification_custom будет инфлейтиться в процессе SystemUI, не в твоём.

                                                                                                                                                                                                   * Там можно использовать только те View, которые поддерживаются RemoteViews (TextView, ImageView, ProgressBar и т.д. + часть своих, но с ограничениями).
Но: кастомные View в нотификациях очень ограничены. RemoteViews по сути выполняет только узкий набор операций: setTextViewText, setImageViewResource, setOnClickPendingIntent, и т.п.
Никакого произвольного кода из твоего кастомного View там не вызовется так, как в обычном layout’е Activity.
В Notification нельзя запускать привычные View-анимации, потому что layout нотификации — это RemoteViews, который инфлейтится и живёт в процессе SystemUI, а не в нашем. Мы можем только описывать изменения через операции RemoteViews или обновлять сам Notification через NotificationManager. Для “анимаций” используют либо встроенные элементы (ProgressBar, Chronometer), либо периодическое обновление содержимого уведомления, либо анимированные drawable-ресурсы. Любые сложные View-анимации (как в Activity) внутри нотификаций недоступны.


20. Как работают анимации, какие есть аниматоры, chareographer
В Android анимации — это просто многократное изменение свойств объекта на каждом кадре. Современная система — это property animations (android.animation): ValueAnimator умеет считать значение от A до B по времени и через addUpdateListener обновлять нужное свойство; ObjectAnimator делает то же самое, но сам вызывает сеттер нужного свойства; ViewPropertyAnimator — сахар для анимации стандартных полей View. Есть ещё AnimatorSet для композиции и physics-based анимации (SpringAnimation, FlingAnimation) для более “живого” поведения.


Вся магия завязана на Choreographer: он получает сигнал VSync, в коллбэке doFrame сначала обрабатывает input, затем анимации (где аниматоры пересчитывают своё значение и вызывают invalidate), и затем запускает measure/layout/draw. Так мы получаем до 60 кадров в секунду, если успеваем всё сделать за ~16 мс.


start() у ValueAnimator
  ↓
регистрируется во внутреннем AnimationHandler
  ↓
AnimationHandler → просит Choreographer вызвать callback на следующий кадр
  ↓
Choreographer.doFrame()
  ↓
ValueAnimator:
  - считает прошедшее время
  - обновляет animatedFraction
  - вызывает updateListener / устанавливает Property
  - если ещё не закончилась → снова просит callback на следующий кадр
  ↓
View.invalidate() / requestLayout()
  ↓
ViewRootImpl.performTraversals()
  - measure/layout/draw
  ↓
RenderThread / GPU
  ↓
SurfaceFlinger → экран


21. Жц compose view, какие есть проблемы, как работают view вместе с compose


class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyScreen()
        }
    }
}


                                                                                                                                                                                                      * setContent { ... } создаёт ComposeView и будет:
                                                                                                                                                                                                      * добавлен в Window как единственный корневой View,
                                                                                                                                                                                                      * внутри себя поднимает “Compose-мир”:
                                                                                                                                                                                                      * Composition,
                                                                                                                                                                                                      * Recomposer,
                                                                                                                                                                                                      * Applier (который мапит Compose-дерево на внутренние view/слоты).

                                                                                                                                                                                                         * MyScreen() вызывается первый раз — это первая композиция.
Дальше:
                                                                                                                                                                                                         * состояние (remember, mutableStateOf, ViewModel и т.д.) меняется → происходит recomposition тех composable, которые зависят от этого стейта.
                                                                                                                                                                                                         * Пока Activity жива — композиция жива.
Когда Activity уничтожается (не только поворот, а именно onDestroy без isChangingConfigurations):
                                                                                                                                                                                                         * ViewTreeLifecycleOwner помечается как destroyed,
                                                                                                                                                                                                         * Compose отслеживает это через ViewTreeLifecycleOwner,
                                                                                                                                                                                                         * композиция dispose’ится → вызываются DisposableEffect.onDispose, закрываются корутины и т.д.
В Compose жизненный цикл UI завязан не на onCreate/onDestroy, а на композицию: composable-функции попадают в Composition через setContent или ComposeView.setContent, далее при изменении состояния происходит recomposition, а при уничтожении LifecycleOwner композиция dispose’ится, вызывая все DisposableEffect.onDispose.


Когда мы встраиваем Compose в старый View-мир через ComposeView, важно правильно настроить ViewCompositionStrategy, чтобы не получить утечки (особенно в Fragment’ах и RecyclerView). Аналогично, когда мы вставляем обычные View в Compose через AndroidView, factory вызывается один раз при создании, а update — при каждой рекомпозиции, и при выходе composable из Composition View уничтожается.


Главные проблемы гибрида View+Compose — это утечки (неправильно освобождённая композиция), особенности работы в списках (ComposeView в RecyclerView), и необходимость правильно синхронизировать стейт между Compose и View.


22. Как compose рекомпозирует
Compose не “перерисовывает экран целиком” — он заново вызывает нужные @Composable функции, которые зависят от изменившегося State.
Это и есть recomposition.
@Composable
fun Counter(count: Int, onClick: () -> Unit) {
    Text("Count = $count")
    Button(onClick = onClick) {
        Text("Increment")
    }
}
Логика такая:
“Вот как должен выглядеть UI, если count = 5”.
Когда count меняется (6, 7, 8…), Compose:
                                                                                                                                                                                                         * не ищет кнопку и текст в дереве view,
                                                                                                                                                                                                         * не меняет “ручками” setText и т.п.
Он делает:
“Окей, count поменялся → давай ещё раз вызовем Counter(...) и посмотрим, какой теперь UI он описывает”.
То есть:
                                                                                                                                                                                                         * состояние изменилось →
                                                                                                                                                                                                         * композиторы перезапускают нужные @Composable функции →
                                                                                                                                                                                                         * фреймворк сравнивает новое дерево с предыдущим и переиспользует всё, что можно.

8.1. Что вызывает recomposition?
                                                                                                                                                                                                            * Изменение State (mutableStateOf, derivedStateOf, snapshotFlow) прочитанных в composable.
                                                                                                                                                                                                            * Изменение параметров composable.
                                                                                                                                                                                                            * Изменение LifecycleOwner/Configuration (например, локали/точки доступа).
                                                                                                                                                                                                            * Навигация и смена экранов.
8.2. Что не вызывает recomposition?
                                                                                                                                                                                                            * Просто изменение обычной переменной, не хранимой в remember / State.
                                                                                                                                                                                                            * Вызовы composable “в стороннем месте” без включения в composition (типа вызывать в обычной функции — бессмысленно).
8.3. Как уменьшать лишние рекомпозиции?
                                                                                                                                                                                                            * Дробить UI на мелкие composable, чтобы зависели от узкого state.
                                                                                                                                                                                                            * Использовать remember для тяжёлых объектов, чтобы не создавать их каждый раз.
                                                                                                                                                                                                            * Использовать derivedStateOf, если нужно вычислять производное значение только когда реально меняются исходные стейты.
                                                                                                                                                                                                            * Следить, чтобы в параметрах composable не “летали” новые объекты каждый раз без нужды (val list = foo.toList() прямо в параметре — плохая идея).
В Compose UI — декларативный, поэтому при изменении состояния он не мутирует существующие View, а делает recomposition — повторный вызов тех @Composable, которые зависят от изменившегося State. State реализовано через snapshot-систему: когда мы читаем mutableStateOf внутри composable, Compose запоминает зависимость; когда значение меняется, соответствующие участки дерева помечаются как dirty. На следующем кадре, через Choreographer, Recomposer проходит по этим dirty-областям, заново вызывает нужные функции и обновляет только изменившиеся части UI. При этом используются механизмы стабильности и сравнение параметров, чтобы пропускать неизменившиеся ветки дерева. remember и State позволяют сохранять значения между рекомпозициями и управлять тем, какие участки UI будут от них зависеть.
23. Compose snapshot
                                                                                                                                                                                                            * mutableStateOf — исходный state (источник данных).
                                                                                                                                                                                                            * derivedStateOf — вычисляемый state, кэширующий результат и избегающий лишних пересчётов/рекомпозиций(подписывается на все state, которые читаются внутри блока { ... };).
                                                                                                                                                                                                            * snapshotFlow — мост: из snapshot state → в Flow, чтобы наблюдать state в корутинах, вне composable.
1. Первая композиция:
   setContent { Screen() }
       ↓
   Recomposer:
     observeReads(Scope#Screen) {
        // читаем stateA, stateB
     }
   Карта:
     stateA → {Scope#Screen}
     stateB → {Scope#Screen}
2. Изменился stateA:
   stateA.value = ...
       ↓
   Snapshot apply observer:
     изменился stateA → грязные scope’ы: {Scope#Screen}
       ↓
   Scope#Screen → dirty
3. Следующий кадр (Choreographer.doFrame):
   Recomposer:
     у нас есть dirty scope: Scope#Screen
       → ещё раз вызываем Screen()
       → пересобираем UI-дерево
       → обновляем карту зависимостей (кто что читает сейчас)


Scope (упрощённо) — это “участок дерева композиции”, соответствующий вызову composable в определённой точке.


В Compose основной тип состояния — это snapshot State (mutableStateOf). Когда composable читают state.value, snapshot-система регистрирует зависимость между этим state и текущим recompose-scope. При изменении state.value в момент применения snapshot’а Recomposer получает список изменённых state’ов, находит все scope’ы, которые их читали, и помечает их как dirty. На следующем кадре Recomposer запускает recomposition только для этих scope’ов, повторно вызывает соответствующие @Composable функции и патчит SlotTable и реальное UI-дерево.


mutableStateOf — это исходный state; derivedStateOf строит кэшируемое производное значение по другим state’ам; snapshotFlow позволяет наблюдать snapshot-состояние в виде Flow в корутинном мире, вне composable.


В Compose под “snapshot state” понимаются все типы состояния, интегрированные с snapshot-системой runtime — mutableStateOf, derivedStateOf, SnapshotStateList и т.д. В отличие от обычных полей, они не только хранят значение, но и участвуют в механизме snapshot’ов: при чтении регистрируют зависимость между state и текущим recompose-scope, а при записи через snapshot-систему помечают эти scope’ы как dirty. Это позволяет Compose делать точечную рекомпозицию и при этом обеспечивать консистентный и многопоточный доступ к состоянию без грубых блокировок — по сути, это MVCC-подход для UI-состояния.


24 @Composable  - во что превращается под капотом в байткоде(composer)


Аннотация @Composable обрабатывается Compose compiler plugin’ом: каждая composable-функция превращается в обычную Kotlin-функцию с дополнительным параметром Composer и набором битовых флагов, которые описывают изменения параметров. Внутри вставляются вызовы startRestartGroup / endRestartGroup, чтобы можно было перезапускать только нужные участки дерева. Когда snapshot state меняется, Recomposer знает, какие именно restart-группы нужно заново выполнить, и вызывает соответствующие @Composable с тем же composer, минимально патча UI.
Composer:
                                                                                                                                                                                                            * ходит по SlotTable (таблица слотов, где хранится всё состояние композиции: remember, эффекты, ключи, ноды UI);
                                                                                                                                                                                                            * управляет группами (groups) — логическими кусками дерева (компонуемыми функциями, if/for и т.д.);
                                                                                                                                                                                                            * управляет узлами (nodes) — реальными объектами UI (в Compose UI — это layout-ноды, draw-ноды и пр.);
                                                                                                                                                                                                            * решает:
                                                                                                                                                                                                            * когда вызвать тело composable,
                                                                                                                                                                                                            * когда пропустить (skip),
                                                                                                                                                                                                            * когда переиспользовать существующие объекты,
                                                                                                                                                                                                            * когда создать/удалить.
Composer — это объект, который ведёт процесс композиции: он ходит по таблице слотов, создаёт и закрывает группы, создаёт/переиспользует UI-ноды и сохраняет значения remember. Compose compiler plugin в каждую @Composable функцию добавляет скрытый параметр Composer и набор флагов изменений. Внутри функции вставляются вызовы типа startRestartGroup, changed(...), skipToGroupEnd, endRestartGroup.


Когда мы вызываем composable в первый раз, Composer записывает в SlotTable всё состояние (remember’ы, ключи, node’ы). При изменении State Recomposer получает список грязных scope’ов и заново вызывает нужные composable, передавая тот же Composer. Composer проходится по SlotTable, видит свои группы и слоты, где возможно — переиспользует существующие node’ы и значения, а где нужно — выполняет код заново. За счёт таких методов как changed, skipToGroupEnd и restart-групп Compose умеет делать очень точечную рекомпозицию.
25. Как происходит превращение из xml в картинку(layout inflator, window, canvas, gpu), тоже самое про compose
┌──────────────────────────────────────────────┐
│ XML layout                                      │         Compose-код (@Composable)│
│ res/layout/*.xml                               │                           setContent { ... }      │
└──────────────┬───────┴──────────────┬────────┘
                                  │                                              │
                                    │                                              │
                                     ▼                                             ▼
┌────────────────────────┐   ┌────────────────────────┐
│ LayoutInflater                                    │   │ Compose Compiler Plugin                    │
│ - парсит XML                                │   │ - добавляет Composer                       │
│ - создаёт View-дерево                       │   │ - генерит группы/слоты                     │
└────────────┬───────────┘   └────────────┬───────────┘
                               │                                                            │
                               ▼                                                           ▼
┌────────────────────────┐   ┌─────────────────────────┐
│ View-дерево (ViewGroup,                     │   │ LayoutNode-дерево                            │
│ TextView, Button, ...)                      │   │ (+ Modifier, Draw)                                   │
└────────────┬───────────┘   └─────────────┬───────────┘
                               │                                                              │
                               └───────────┬───────────────┘
                                                      ▼
                  ┌────────────────┐
                  │ DecorView                         │
                  │  └─ либо View’ы,
                  │  └─ либо ComposeView
                  └────────┬───────┘
                                         ▼
                 ┌─────────────────┐
                 │  ViewRootImpl                │
                 │  - measure                              │
                 │  - layout                               │
                 │  - draw                             │
                 └─────────┬───────┘
                                          ▼
                 ┌─────────────────┐
                 │   Canvas                             │
                 │   (HW accel.)                        │
                 └─────────┬───────┘
                           ▼
                 ┌─────────────────┐
                 │ RenderThread /                    │
                 │      GPU                                │
                 └─────────┬───────┘
                                          ▼
                 ┌─────────────────┐
                 │  Surface /                           │
                 │  BufferQueue                             │
                 └─────────┬───────┘
                                          ▼
                 ┌─────────────────┐
                 │  SurfaceFlinger                      │
                 │  (композитит все                │
                 │   окна)                                 │
                 └─────────┬───────┘
                                          ▼
                 ┌─────────────────┐
                 │   ДИСПЛЕЙ                            │
                 └─────────────────┘


26. jit(dalvik) компиляци и aot(в art), отличия, что такое dex(виртуальная машина android), сейчас профилирующий компилятор


В старом Dalvik код приложений исполнялся из DEX-байткода через интерпретатор, а горячие методы JIT-компилировались на лету. Компилированный код жил только в памяти процесса, после убийства процесса всё приходилось разогревать заново. Это давало быстрый install, но старт и производительность сильно зависели от JIT и приводили к лишней нагрузке.


В ART первоначально сделали сильный упор на AOT: при установке приложения DEX компилировался в нативный код (dex2oat), и на старте уже использовался готовый ELF/ОAT. Это ускорило запуск и выполнение, но замедлило установку и сильно увеличило размер кода на диске.


Современный ART использует гибридную, профилирующую стратегию: сначала код может интерпретироваться, работает JIT, который собирает профиль и компилирует горячие участки, а позже, когда устройство на зарядке и в idle, по этим профилям запускается AOT-компиляция только наиболее часто используемых методов. Таким образом совмещаются плюсы JIT и AOT.
DEX при этом — это просто формат байткода для Android, в который компилируются .class файлы; его выполняет виртуальная машина (раньше Dalvik, сейчас ART), а не наоборот.
27. Что такое R8(гибрид между android compiler и proguard), зачем нужен
R8 — это встроенный в Android Gradle Plugin код-шринкер и обфускатор, который совмещает в себе функции ProGuard и D8. Он берёт .class файлы, удаляет неиспользуемый код, делает оптимизации, переименовывает классы и методы и сразу генерирует .dex. Это уменьшает размер APK/AAB, ускоряет загрузку и немного усложняет реверс-инжиниринг. Сейчас при minifyEnabled true именно R8 выполняет все эти задачи, а не ProGuard, при этом использует совместимый синтаксис правил proguard-rules.pro.


Kotlin/Java код
   ↓ kotlinc/javac
.class файлы
   ↓ R8  (вместо ProGuard + D8)
[shrink + optimize + obfuscate + dex]
   ↓
classes.dex (уже ужатые и запутанные)
   ↓ упаковка
APK/AAB
28. Что такое deepLink, как работают


Deep link — это URI, который открывает не просто приложение, а конкретный экран или состояние внутри него. В Android это реализовано через implicit Intent с ACTION_VIEW + intent-filter в манифесте: мы описываем scheme/host/path, которые Activity умеет обрабатывать. При клике по такой ссылке система находит подходящее приложение, запускает нужную Activity и передаёт ей URI через intent.data, по которому мы восстанавливаем состояние. Есть кастомные схемы (myapp://), HTTP/HTTPS deep links и Android App Links, где домен криптографически привязан к приложению и система может сразу открывать аппу без выбора браузера.


Многопоточка


1. Почему корутина - легковесный поток(continuation) как работает suspend, как работают под копотом, continuationLabel, coroutineBuilder
ОС-поток (Thread):
                                                                                                                                                                                                            * создаётся через ядро ОС → дорого: стек (обычно сотни КБ–МБ), переключение контекста через kernel, синхронизация и т.д.;
                                                                                                                                                                                                            * если поток “ждёт” (сетевой запрос, таймер) → он всё равно занят (заблокирован в sleep, read, wait, и т.п.), его нужно парковать/распарковать;
                                                                                                                                                                                                            * 10к потоков = боль.
Корутина:
                                                                                                                                                                                                            * это обычный объект в heap’е, который описывает “где мы остановили выполнение и как продолжать”;
                                                                                                                                                                                                            * сама корутина не привязана 1:1 к потоку:
                                                                                                                                                                                                            * корутина может за жизнь побывать на разных потоках (Dispatchers.Default, IO, Main);
                                                                                                                                                                                                            * когда корутина “ждёт” (например, delay, сетевой запрос):
                                                                                                                                                                                                            * ни один поток не блокируется;
                                                                                                                                                                                                            * корутина просто “паркуется” → её Continuation лежит в памяти и ждёт resume;
                                                                                                                                                                                                            * thread, на котором она подвисла, освобождается и может обслуживать другие корутины.
В Kotlin корутина — это не поток ОС, а объект, описывающий “продолжение” выполнения. suspend-функции компилятор разворачивает в state-machine с дополнительным параметром Continuation. Внутри создаётся класс с полем label и локальными переменными; каждый suspend — это состояние автомата. При вызове другого suspend он либо продолжает выполнение сразу, либо возвращает специальный маркер COROUTINE_SUSPENDED. Тогда функция выходит, поток освобождается, а все нужные данные остаются в объекте continuation. Позже, когда операция завершилась, кто-то вызывает resumeWith, state-machine заходит снова и продолжает с нужного состояния (label).


Coroutine builders (launch, async, withContext) — это просто функции, которые создают контекст + Job, строят continuation для переданной suspend-лямбды и запускают её через startCoroutine на нужном dispatcher’е. Всё это позволяет иметь тысячи корутин поверх небольшого пула потоков, поэтому их называют “легковесными потоками”: они не блокируют thread при ожидании, а сохраняют continuation на куче и резюмируются, когда результат готов.
2. Как под капотом работает withContext, launch, async, runBlocking, различные Dispatchers, cancellabcleCrorutine?


launch и async — это корутинные билдеры, которые создают новый Job и контекст, оборачивают переданный suspend-блок в continuation и запускают его через startCoroutine на выбранном Dispatcher. launch возвращает Job (fire-and-forget), async — Deferred<T> с результатом и await().


withContext — это suspend-функция, которая временно переключает корутину в другой контекст: внутри создаётся дочерняя корутина с новым dispatcher’ом и Job, текущая корутина подвешивается до её завершения, а результат возвращается как обычное значение.


runBlocking делает обратное: создаёт корутину в текущем потоке и блокирует этот поток, пока корутина не завершится, но при этом внутри крутит event loop и выполняет задачи корутин.


Dispatchers (Default, IO, Main, Unconfined) — это разные реализации CoroutineDispatcher, которые, перехватывая continuation, решают, в каком потоке/пуле резюмировать корутину.


suspendCancellableCoroutine и его CancellableContinuation — это низкоуровневый механизм, который позволяет превращать callback-ориентированные async-API в suspend-функции с поддержкой отмены: мы получаем continuation, регистрируем обработчик отмены и резюмируем корутину из callback’а, когда операция завершена.
                                                                                                                                                                                                            * launch
                                                                                                                                                                                                            * создаётся StandaloneCoroutine / Job, который сам является Continuation<Unit>;
                                                                                                                                                                                                            * startCoroutineCancellable(block, coroutine) запускает state-machine блока.
                                                                                                                                                                                                            * async:
                                                                                                                                                                                                            * создаётся DeferredCoroutine<T> (наследует AbstractCoroutine<T>, реализует Deferred<T> + Continuation<T>).
                                                                                                                                                                                                            * withContext:
                                                                                                                                                                                                            * внутри создаётся ScopeCoroutine<T> (дочерний Job + Continuation), который:
                                                                                                                                                                                                            * запускает блок на новом dispatcher’е,
                                                                                                                                                                                                            * по завершении резюмирует оригинальный Continuation (this).
                                                                                                                                                                                                            * runBlocking:
                                                                                                                                                                                                            * создаётся BlockingCoroutine<T> + EventLoop;
                                                                                                                                                                                                            * runBlocking блокирует текущий поток, пока этот BlockingCoroutine не завершится, при этом крутит event loop.
                                                                                                                                                                                                            * Dispatchers:
                                                                                                                                                                                                            * в Java выглядят как singletons и параметры,
                                                                                                                                                                                                            * реально оборачивают Continuation в DispatchedContinuation, в котором resumeWith делает dispatcher.dispatch(ctx, this).
                                                                                                                                                                                                            * suspendCancellableCoroutine:
                                                                                                                                                                                                            * создаёт CancellableContinuationImpl<T> – continuation, связанный с Job + Dispatcher,
                                                                                                                                                                                                            * твой callback вызывает cont.resume(...),
                                                                                                                                                                                                            * отмена через cont.invokeOnCancellation.

На уровне скомпилированного Java-кода launch и async — это просто обычные статические функции из kotlinx.coroutines, которые создают соответствующие классы корутин (StandaloneCoroutine, DeferredCoroutine) и запускают переданный suspend-блок через startCoroutineCancellable. Они сами не являются suspend и не участвуют в state-machine вызывающей функции.


withContext, await, suspendCancellableCoroutine — наоборот, это suspend-функции: компилятор добавляет к вызову управление через Continuation и label: перед вызовом выставляется label, передаётся текущий Continuation (this), результат проверяется на COROUTINE_SUSPENDED. Поэтому они становятся частью state-machine вызывающей корутины.


runBlocking выглядит как обычный Java-вызов BuildersKt.runBlocking(...): он создаёт BlockingCoroutine и блокирует текущий поток, пока корутина не завершится, при этом крутит свой event loop.


Dispatchers в Java — просто синглтоны, которые кладутся в CoroutineContext Continuation’а и перехватывают его как ContinuationInterceptor, оборачивая в DispatchedContinuation. Уже при resumeWith они решают, в каком потоке/пуле вызвать continuation, через метод dispatch.


3. launch(исключение наверх до родителья), async(и до родителя и в defered, надо обработать await), какая разница, как работают
Что возвращает
                                                                                                                                                                                                               * launch → Job (без результата)
                                                                                                                                                                                                               * async → Deferred<T> (есть результат/ошибка)
3.2. Где “живёт” исключение
                                                                                                                                                                                                               * launch:
                                                                                                                                                                                                               * исключение идёт в стейт Job и сразу отдаётся наверх:
                                                                                                                                                                                                               * родителю → для отмены,
                                                                                                                                                                                                               * CoroutineExceptionHandler/uncaughtExceptionHandler → для логов/краша.
                                                                                                                                                                                                               * async:
                                                                                                                                                                                                               * исключение кладётся внутрь Deferred как CompletedExceptionally;
                                                                                                                                                                                                               * родитель тоже узнаёт (отмена), но:
                                                                                                                                                                                                               * само исключение “должен” получить тот, кто вызовет await().
3.3. Когда исключение реально “выстреливает” наружу
                                                                                                                                                                                                               * launch:
                                                                                                                                                                                                               * сразу, как только корутина завершилась с ошибкой (если ты не поймал её внутри);
поэтому:
launch {
    error("boom") // сразу улетит в handler/лог
}
                                                                                                                                                                                                               * async:

при await():

val d = async { error("boom") }
d.await()             // здесь throw
}
3.4. Взаимодействие с родителем (job hierarchy)
Оба:
                                                                                                                                                                                                                  * являются детьми родительского Job (если внутри coroutineScope, viewModelScope и т.д.);
                                                                                                                                                                                                                  * при исключении:
                                                                                                                                                                                                                  * отменяют родителя, если тот — обычный Job (не SupervisorJob);
                                                                                                                                                                                                                  * родитель отменяет всех других детей.
Пример:
coroutineScope {
    val d = async {
        delay(100)
        error("boom")
    }
    launch {
        // этот launch будет отменён когда async упадёт
        try {
            while (isActive) {
                delay(50)
                println("still working")
            }
        } finally {
            println("cancelled")
        }
    }
    d.await() // бросит исключение
}
                                                                                                                                                                                                                  * и launch, и async — дети одного coroutineScope;
                                                                                                                                                                                                                  * ошибка в async:
                                                                                                                                                                                                                  * отменяет coroutineScope и launch,
                                                                                                                                                                                                                  * бросается при await().
В supervisorScope/SupervisorJob логика другая (дети не валят родителя), но принцип одинаковый и для launch, и для async.
CoroutineExceptionHandler — это в первую очередь механизм для корутин типа launch и root-корутин.
Для async правильный путь — оборачивать await() в try/catch.


launch и async оба создают дочерние корутины и оба при ошибке отменяют родительский Job. Разница в том, как они обращаются с исключением как с результатом. У launch нет значения, поэтому исключение считается “неконтролируемым” и сразу уходит в обработчик исключений корутин (CoroutineExceptionHandler / uncaughtExceptionHandler), а Job помечается как завершён с ошибкой. У async есть результат, поэтому исключение сохраняется внутри Deferred и выбрасывается только при await(). То есть для async ошибка является частью значения, а для launch — концом корутины. Именно поэтому launch используют для сайд-эффектов, а async — для параллельных вычислений, где мы обязательно делаем await() и явно обрабатываем ошибки.
На уровне JVM есть базовый механизм Thread.UncaughtExceptionHandler: когда исключение долетает до верхушки стека потока и нигде не было поймано, оно передаётся в этот handler, а на Android обычно приводит к падению процесса.


В корутинах поверх этого есть свой механизм — CoroutineExceptionHandler, который является элементом CoroutineContext. Если корутина завершилась с исключением и это исключение не было поймано локально и не было обработано родительским Job’ом, то на уровне root-корутины оно считается “unhandled coroutine exception” и передаётся в CoroutineExceptionHandler.handleException(context, throwable). Если собственного CoroutineExceptionHandler в контексте нет, то kotlinx.coroutines по умолчанию делегирует обработку в Thread.uncaughtExceptionHandler текущего потока.


Для launch необработанное исключение обычно попадает сразу в CoroutineExceptionHandler, а для async — сохраняется внутри Deferred и выбрасывается при await(), то есть для async ошибки чаще обрабатываются обычным try/catch вокруг await().
4. Модель: дерево Job’ов (родитель–дети)

launch/async/runBlocking:


root Job (например, viewModelScope)
 ├─ child Job (launch { ... })
 │   └─ ещё child (withContext { ... })
 └─ child Job (async { ... })
Каждый Job знает:
                                                                                                                                                                                                                  * своего родителя (parent),
                                                                                                                                                                                                                  * своих детей (children),
                                                                                                                                                                                                                  * своё состояние: Active → Cancelling → Cancelled/Completed.
Ключевой принцип structured concurrency:
Пока родительский scope жив/не завершён, его дети тоже живут внутри него,
родитель ждёт завершения всех детей (если он coroutineScope / runBlocking / и т.п.).
Каждый launch/async:
                                                                                                                                                                                                                  * создаёт новый Job (конкретный класс: StandaloneCoroutine, DeferredCoroutine<T>);
                                                                                                                                                                                                                  * делает его дочерним текущего scope.coroutineContext[Job].

withContext:
parent Job (корутина, которая вызвала withContext)
 └─ Job (withContext-child)
                                                                                                                                                                                                                     * создаёт дочерний Job от текущего;
                                                                                                                                                                                                                     * запускает block как отдельную корутину;
                                                                                                                                                                                                                     * подвешивает текущую корутину до завершения withContext-блока;
                                                                                                                                                                                                                     * возвращает результат.
suspendCancellableCoroutine:
Job (current coroutine)
  └─ тело корутины
       └─ suspendCancellableCoroutine { ... }  // всё в том же Job
Важно: сам по себе новый Job НЕ создаёт.
                                                                                                                                                                                                                     * CancellableContinuation привязан к текущему Job’у через cont.context[Job].
                                                                                                                                                                                                                     * Отмена родителя отменит этот continuation.
                                                                                                                                                                                                                     * Но это не отдельная корутина и не самостоятельный child-Job.
Отмена/завершение в обычном Job (НЕ supervisor)
Правила для обычного Job (по умолчанию):
3.1. Родитель отменён → все дети отменяются
Происходит:
                                                                                                                                                                                                                     * parent переходит в состояние Cancelling → Cancelled;
                                                                                                                                                                                                                     * всем детям шлётся cancel(CancellationException):
                                                                                                                                                                                                                     * child1 и child2 получают isActive = false;
                                                                                                                                                                                                                     * любой suspend внутри них бросит CancellationException;
                                                                                                                                                                                                                     * все suspendCancellableCoroutine’ы внутри получат invokeOnCancellation.
3.2. Child завершился нормально → родитель не отменяется
Обычное завершение:
                                                                                                                                                                                                                     * ребёнок переходит в Completed, родитель живёт дальше.
                                                                                                                                                                                                                     * родитель coroutineScope или runBlocking просто ждёт всех детей и потом тоже завершается.

3.3. Child кинул исключение → родитель отменяется
Главное правило:
В обычном Job: исключение в child → отмена родителя → отмена всех siblings.


4. Исключения: launch vs async в этой иерархии
С точки зрения иерархии Job’ов:
                                                                                                                                                                                                                        * и launch, и async — одинаковые дети:
если их Job завершился с исключением → родитель получает исключение и отменяется (если это не supervisor).
Разница только в том, как ты получаешь эту ошибку в коде:


5. Что меняет SupervisorJob/ supervisorScope
Отличие SupervisorJob:
Ошибка в ребёнке НЕ отменяет родителя и его других детей.
Родитель при этом всё ещё может отменить ребёнка.


SupervisorJob parent
 ├─ child1 (launch)
 └─ child2 (async)
Если child1 упал с исключением:
                                                                                                                                                                                                                           * child1 = CompletedExceptionally(boom);

                                                                                                                                                                                                                           * parent остаётся Active;

                                                                                                                                                                                                                           * child2 остаётся Active;

                                                                                                                                                                                                                           * никакой массовой отмены нет.

Если parent.cancel():
                                                                                                                                                                                                                              * все дети (включая успешные/упавшие/живые) получают отмену, как в обычном Job.

5.2. supervisorScope
suspend fun f() = supervisorScope {
    launch { ... }      // supervised child1
    launch { ... }      // supervised child2
}
outer Job
 └─ SupervisorJob (supervisorScope)
      ├─ child1 (launch)
      └─ child2 (launch)
Если child1 упал:
                                                                                                                                                                                                                                 * SupervisorJob не отменяется;
                                                                                                                                                                                                                                 * child2 работает дальше.

Если supervisorScope выкинет исключение сам (например, ты сделаешь throw в его теле), он завершится с исключением и это уже придёт к outer Job.
У корутин есть дерево Job’ов: любой launch/async/withContext создают дочерний Job от текущего, а coroutineScope и runBlocking ждут завершения всех детей. Для обычного Job действует правило: при исключении в дочерней корутине оно поднимается к родителю, родитель помечается как отменённый и рекурсивно отменяет всех детей. То есть ошибка одного child’а валит siblings.


SupervisorJob и supervisorScope меняют только одно: исключение в дочерней корутине не отменяет родителя и других детей. Родитель всё ещё может отменить их всех, но дети не “валят” друг друга. Чтобы child не валил parent, либо используем SupervisorJob/supervisorScope, либо ловим исключение локально внутри этого child. Чтобы parent не валил child, по сути надо создавать отдельный root-CoroutineScope с собственным Job — иначе по правилам structured concurrency отмена родителя всегда отменяет всех детей.


suspendCancellableCoroutine нового Job не создаёт, он просто встраивается в существующую корутину: её Job управляет отменой продолжения, а все исключения, которые ты резюмируешь через continuation, ведут себя так, как если бы ты throw сделал внутри этой же корутины.
5. Как синхронизировать 2 корутины, акторы(каналы), обмен данными между корутинами
Синхронизация “по событию”:
                                                                                                                                                                                                                                    * job.join() / deferred.await() — дождаться завершения.
val job1 = launch { /* работа 1 */ }
val job2 = launch { /* работа 2 */ }


job1.join()   // дождаться 1
job2.join()   // потом 2
 или 
val d1 = async { calc1() }
val d2 = async { calc2() }


val r1 = d1.await()
val r2 = d2.await()


                                                                                                                                                                                                                                    * CompletableDeferred — барьер/сигнал.
val startSignal = CompletableDeferred<Unit>()
launch {
    startSignal.await()      // ждём общего старта
    println("A started")
}
launch {
    startSignal.await()
    println("B started")
}
// где-то позже:
startSignal.complete(Unit)   // обе корутины одновременно снимаются с паузы
CompletableDeferred — это по сути Deferred без вычислений, ты вручную дергаешь complete.
Обмен данными:
                                                                                                                                                                                                                                    * Один к одному / один ко многим:
                                                                                                                                                                                                                                    * Channel<T>:
                                                                                                                                                                                                                                    * send/receive,
                                                                                                                                                                                                                                    * тип буфера задаёт поведение (блокируется или нет).
val channel = Channel<Int>()  // по умолчанию rendezvous (без буфера)
// корутина-отправитель
launch {
    for (i in 1..5) {
        channel.send(i)   // suspend, если некому принять
    }
    channel.close()       // сигнал "данных больше не будет"
}
// корутина-получатель
launch {
    for (x in channel) {   // for по каналам = receive до close
        println("Got $x")
    }
    println("Done")
}
Как это работает под капотом:
                                                                                                                                                                                                                                    * У Channel есть очередь ожидающих send’еров и очередь ожидающих receive’еров.
                                                                                                                                                                                                                                    * Если канал без буфера (RENDEZVOUS):
                                                                                                                                                                                                                                    * send(x):
                                                                                                                                                                                                                                    * если уже есть ожидающий receive → сразу передаёт данные и оба продолжают;
                                                                                                                                                                                                                                    * если нет → send подвешивает корутину до появления получателя;
                                                                                                                                                                                                                                    * receive():
                                                                                                                                                                                                                                    * если есть ожидающий send → сразу забирает значение;
                                                                                                                                                                                                                                    * если нет → подвешивается.
                                                                                                                                                                                                                                    * Если есть буфер (Channel(capacity)), то часть send’ов помещается в буфер и не блокирует/не suspend’ит сразу.
Типы:
                                                                                                                                                                                                                                    * Channel.RENDEZVOUS (по умолчанию): синхронный обмен — обе стороны должны встретиться.
                                                                                                                                                                                                                                    * Channel.UNLIMITED: почти бесконечный буфер.
                                                                                                                                                                                                                                    * Channel.CONFLATED: хранит только последний элемент (старые затираются).
                                                                                                                                                                                                                                    * Channel.BUFFERED: фиксированный размер.
Это главный базовый примитив “обмена данными между корутинами” в kotlinx.coroutines.
                                                                                                                                                                                                                                    * Многие к одному с состоянием:
                                                                                                                                                                                                                                    * актор = launch { for (msg in channel) handle(msg) }.
Актор — это паттерн: “одна корутина владеет состоянием, общение с ней — только через сообщения в канал”.
То есть:
                                                                                                                                                                                                                                    * есть actor-корутина,
                                                                                                                                                                                                                                    * у неё есть Channel<Message>,
                                                                                                                                                                                                                                    * она единственная, кто мутирует состояние.
Это убирает проблемы с mutex / гонками: никто кроме актёра к состоянию не лезет.
Ошибки/отмена:
                                                                                                                                                                                                                                    * если корутина, которая читает из канала, упала → все, кто пытается send, могут получить исключение/отмену;
                                                                                                                                                                                                                                    * если закрываешь канал channel.close(cause) → получатели увидят ClosedReceiveChannelException/с cause;
                                                                                                                                                                                                                                    * обмен через Channel нормально переживает отмены и входит в общую иерархию Job’ов.
6. Что такое корутины(подход)
Корутины — это модель конкурентного и асинхронного программирования, в которой долгие операции описываются обычными последовательными suspend-функциями, а компилятор разворачивает их в state-машины с continuation. Это позволяет приостанавливать и возобновлять вычисления без блокировки потоков, запускать тысячи задач поверх небольшого пула потоков и управлять ими через дерево Job’ов (structured concurrency). В отличие от потоков, корутины лёгкие, в отличие от callback’ов — читаемы, и в отличие от “голого” async/future — дают нормальные правила по ошибкам и отмене.


7. В чем разница между асинхронностью, паралельностью, многопоточностью и cuncurency


Многопоточность — это когда в одном процессе есть несколько потоков выполнения (OS threads).
Характеристики:
                                                                                                                                                                                                                                    * Каждому потоку ОС выделяется:
                                                                                                                                                                                                                                    * собственный стек,
                                                                                                                                                                                                                                    * регистры, контекст.
                                                                                                                                                                                                                                    * Переключение между потоками:
                                                                                                                                                                                                                                    * делает планировщик ОС,
                                                                                                                                                                                                                                    * дорого: переключается контекст ядра, кеши, стеки.
                                                                                                                                                                                                                                    * В JVM: new Thread { ... }.start() → один OS thread.
Параллелизм — это когда несколько задач реально выполняются одновременно.
То есть физически на нескольких ядрах/процессорах.
                                                                                                                                                                                                                                    * Чтобы был параллелизм → нужно как минимум несколько ядер.
                                                                                                                                                                                                                                    * Можно иметь многопоточность без параллелизма:
                                                                                                                                                                                                                                    * один ядро, 100 потоков → они просто по очереди получат время.
                                                                                                                                                                                                                                    * Параллелизм — про производительность:
ускоряем вычисления, деля их по ядрам.
Concurrency — это когда несколько задач продвигаются вперёд во времени одновременно,
но не обязательно физически в один момент времени.
То есть:
                                                                                                                                                                                                                                       * задачи переплетены во времени:
                                                                                                                                                                                                                                       * кусочек задачи A,
                                                                                                                                                                                                                                       * потом кусочек задачи B,
                                                                                                                                                                                                                                       * потом опять A…
                                                                                                                                                                                                                                       * Может быть 0 параллелизма (одно ядро), но есть конкурентность:
                                                                                                                                                                                                                                       * OS/Runtime переключает контекст между задачами,
                                                                                                                                                                                                                                       * пользователь видит, что и UI живой, и сеть работает, и музыка играет.
Concurrency — это про структуру программы и модели взаимодействия задач, а не про железо.
Асинхронность — это способ организовать выполнение операций, при котором
вызывающий код не блокируется и не ждёт прямолинейно, а получает результат “потом”.
Это абстракция про API, а не про потоки/ядра:
                                                                                                                                                                                                                                       * асинхронный вызов:
                                                                                                                                                                                                                                       * запускает операцию (обычно I/O: сеть, диск, таймер),
                                                                                                                                                                                                                                       * сразу возвращает управление,
                                                                                                                                                                                                                                       * результат приходит через:
                                                                                                                                                                                                                                       * callback,
                                                                                                                                                                                                                                       * future/promise,
                                                                                                                                                                                                                                       * suspend-продолжение.
async можно реализовать:
                                                                                                                                                                                                                                       * на одном потоке без параллелизма (event loop):
                                                                                                                                                                                                                                       * JavaScript: один поток, куча async.
                                                                                                                                                                                                                                       * на пуле потоков:
                                                                                                                                                                                                                                       * async API, но внутри просто Thread.sleep на другом потоке.
                                                                                                                                                                                                                                       * с корутинами:
                                                                                                                                                                                                                                       * suspend-функция, которая ставит callback и возвращает COROUTINE_SUSPENDED.
8. Как работают стандартные Dispatchers, как работают под капотом
Dispatcher в корутинах — это элемент контекста, который решает “на каком потоке/пуле продолжать корутину”.
abstract class CoroutineDispatcher :
    AbstractCoroutineContextElement(ContinuationInterceptor),
    ContinuationInterceptor {
    // нужен ли dispatch
    open fun isDispatchNeeded(context: CoroutineContext): Boolean = true
    // как отправить задачу на исполнение
    abstract fun dispatch(context: CoroutineContext, block: Runnable)
    open fun dispatchYield(context: CoroutineContext, block: Runnable) { ... } // для yield()
}
ContinuationInterceptor:
                                                                                                                                                                                                                                       * перехватывает Continuation:
                                                                                                                                                                                                                                       * оборачивает в DispatchedContinuation,
                                                                                                                                                                                                                                       * чтобы resumeWith корутины шёл через dispatcher.dispatch(...).
2. Dispatchers.Default - глобальный work-stealing пул
Это пул потоков для CPU-bound задач, общий на всё приложение/процесс.
Принципиально:
                                                                                                                                                                                                                                       * есть глобальный DefaultScheduler:
                                                                                                                                                                                                                                       * набор worker-потоков (примерно max(2, min(число_ядер, 64)));
                                                                                                                                                                                                                                       * у каждого потока своя локальная очередь задач;
                                                                                                                                                                                                                                       * есть глобальная очередь;
                                                                                                                                                                                                                                       * реализован work-stealing: свободный поток крадёт задачи из чужих очередей.
когда вызываешь launch(Dispatchers.Default) { ... } корутина, после suspend/resume, выполняется как Runnable в этом пуле.
object Default : CoroutineDispatcher() {
    private val pool = WorkerPool() // свой планировщик
    override fun isDispatchNeeded(context: CoroutineContext): Boolean = 
        !isCurrentThreadWorker() // если уже внутри worker — можно выполнить сразу
    override fun dispatch(context: CoroutineContext, block: Runnable) {
        pool.submit(block)  // кладём задачу в очередь, будим worker
    }
}
Внутри WorkerPool:
                                                                                                                                                                                                                                       * массив worker-потоков,
                                                                                                                                                                                                                                       * у каждого — deque задач,
                                                                                                                                                                                                                                       * глобальная очередь для “общих” задач,
                                                                                                                                                                                                                                       * worker:
                                                                                                                                                                                                                                       * берёт задачу из своей очереди
                                                                                                                                                                                                                                       * если нет — крадёт у других / из глобальной
                                                                                                                                                                                                                                       * если всё пусто — засыпает.
Важное следствие
                                                                                                                                                                                                                                       * Dispatchers.Default — шарится между всеми корутинными scope’ами:
                                                                                                                                                                                                                                       * GlobalScope, viewModelScope (если не Main), IO, Default, withContext(Default).
                                                                                                                                                                                                                                       * Если ты забьёшь его тяжёлым CPU (огромный цикл, без yield/suspend) → всем будет плохо (UI не обновится, delay’и будут с лагами, и т.д.).
3. Dispatchers.IO - надстройка над Default для блокирующего I/O
Идея:
Разделить “нормальные” CPU задачи и блокирующие (blocking IO: file.read(), JDBC, старый HTTP-клиент), но при этом не плодить отдельный пул на каждую либу.
Dispatchers.IO — это:
                                                                                                                                                                                                                                       * не отдельный независимый пул, а надстройка над DefaultScheduler:
                                                                                                                                                                                                                                       * использует те же worker-потоки;
                                                                                                                                                                                                                                       * но позволяет временно расширять количество потоков для блокирующих задач.
object IO : CoroutineDispatcher() {
    private val default = Dispatchers.Default
    private val semaphore = Semaphore(maxIoThreads) // лимит параллельного IO
    override fun dispatch(context: CoroutineContext, block: Runnable) {
        default.dispatch(context) {
            // пометить задачу как blocking
            // при необходимости поднять дополнительный worker
            runBlockingIo(block)
        }
    }
}
                                                                                                                                                                                                                                       * IO-задачи отмечаются как “blocking”;
                                                                                                                                                                                                                                       * планировщик может поднять дополнительный worker-поток, если много блокирующих вызовов, чтобы CPU-bound задачи из Default не умерли;
                                                                                                                                                                                                                                       * при этом всё равно есть глобальный лимит на количество потоков, чтобы не превратить всё в 500 потоков.
Dispatchers.Main - UI-поток / главный event loop
Dispatchers.Main = обёртка над Handler(Looper.getMainLooper()).


class HandlerContext(
    private val handler: Handler,
) : MainCoroutineDispatcher() {


    override fun isDispatchNeeded(context: CoroutineContext): Boolean {
        // если не на main thread → нужно постить
        return Looper.myLooper() != handler.looper
    }


    override fun dispatch(context: CoroutineContext, block: Runnable) {
        handler.post(block)   // отправляем Runnable в очередь Looper’а
    }
}
Поведение:
                                                                                                                                                                                                                                       * если вызываешь launch(Dispatchers.Main) уже из main-потока:
                                                                                                                                                                                                                                       * isDispatchNeeded = false → resume может выполниться немедленно (без доп. поста).
                                                                                                                                                                                                                                       * если резюмируешь корутину из фонового потока:
                                                                                                                                                                                                                                       * dispatcher сделает handler.post { continuation.run() } → код выполнится на UI-потоке.
На других платформах Main отличается:
                                                                                                                                                                                                                                       * JVM (Swing) → EDT,
                                                                                                                                                                                                                                       * JavaFX → свой Application thread,
                                                                                                                                                                                                                                       * JS → event loop браузера,
                                                                                                                                                                                                                                       * Native → свой MainLoop (если включён).

Dispatchers.Unconfined - “выполняйся там, где тебя резюмнули”
Это специальный, “странный” dispatcher:
                                                                                                                                                                                                                                          * он не закреплён ни за каким пулом/потоком;
                                                                                                                                                                                                                                          * поведение:
                                                                                                                                                                                                                                          * при первом запуске корутин → выполняет сразу в текущем стеке;
                                                                                                                                                                                                                                          * при suspend/resume → продолжение выполняется на том потоке, где был вызван resumeWith.
В Kotlin CoroutineDispatcher — это элемент контекста, реализующий ContinuationInterceptor: он перехватывает continuation корутины и решает, на каком потоке/пуле запускать её продолжение. При резюме корутины DispatchedContinuation.resumeWith либо выполняет continuation сразу, либо делегирует его в dispatcher.dispatch(context, runnable).


Dispatchers.Default — глобальный work-stealing пул потоков для CPU-bound задач: фиксированное количество worker’ов, локальные очереди задач, глобальная очередь, работа распределяется между потоками с помощью work-stealing.


Dispatchers.IO — надстройка над Default, которая помечает задачи как блокирующие I/O и позволяет временно расширять количество потоков для таких задач, чтобы они не блокировали CPU-пул.


Dispatchers.Main на Android обёрнут вокруг Handler(Looper.getMainLooper()): dispatch = handler.post(runnable), а isDispatchNeeded проверяет, на main ли мы сейчас.


Dispatchers.Unconfined — особый dispatcher, который не привязан к конкретному потоку: он стартует корутину в текущем стеке, а после первого suspend’а продолжение выполняется в том потоке, который вызвал resumeWith. Это удобно для низкоуровневого кода, но обычно не стоит использовать в UI.
9. Что делает ContinuationInterceptor?
                                                                                                                                                                                                                                          * CoroutineDispatcher реализует ContinuationInterceptor.
                                                                                                                                                                                                                                          * interceptContinuation обычно возвращает DispatchedContinuation:
                                                                                                                                                                                                                                          * обёртку над исходным continuation, которая:
                                                                                                                                                                                                                                          * в resumeWith не сразу выполняет корутину,
а сначала вызывает dispatcher.dispatch(context, Runnable { delegate.resumeWith(result) }).
ContinuationInterceptor — это точка, где dispatcher “влезает” между корутиной и её продолжением и получает контроль над тем, на каком потоке / когда вызвать resumeWith.
10. “Набор worker-потоков” – что это?
Это просто пул потоков, которыми владеет планировщик корутин (например, DefaultScheduler у Dispatchers.Default).
                                                                                                                                                                                                                                             * Каждый worker — обычный Thread.
                                                                                                                                                                                                                                             * Они крутят бесконечный цикл:
                                                                                                                                                                                                                                             * достают задачу (Runnable) из очередей,
                                                                                                                                                                                                                                             * выполняют,
                                                                                                                                                                                                                                             * снова ищут следующую задачу,
                                                                                                                                                                                                                                             * засыпают, если работы нет.
Это общие потоки, которые используются всеми launch/async/withContext, если в контексте Dispatchers.Default/IO.
10. Локальная и глобальная очереди задач
В нормальном планировщике (как у Kotlin/ForkJoinPool/Go):
                                                                                                                                                                                                                                             * У каждого worker-потока есть своя локальная double-ended очередь (deque) задач.
                                                                                                                                                                                                                                             * Плюс есть глобальная очередь для задач, не привязанных к конкретному worker’у.
Почему так:
                                                                                                                                                                                                                                             * Локальная очередь:
                                                                                                                                                                                                                                             * уменьшает contention (каждый поток чаще работает с “своей” очередью),
                                                                                                                                                                                                                                             * кеш-локальность выше.
                                                                                                                                                                                                                                             * Глобальная:
                                                                                                                                                                                                                                             * используется для задач “общих”,
                                                                                                                                                                                                                                             * оттуда воркеры берут работу, когда у них локально пусто.
11. Что такое work-stealing
Work-stealing = алгоритм балансировки, когда свободный worker-поток “крадёт” задачи у занятых.
Сценарий:
                                                                                                                                                                                                                                             * Worker-1 забит задачами (его локальная очередь длинная).
                                                                                                                                                                                                                                             * Worker-2 ничем не занят (его очередь пустая).
                                                                                                                                                                                                                                             * Вместо того чтобы всё время грузить Worker-1, Worker-2:
                                                                                                                                                                                                                                             * заглядывает в очереди других worker’ов,
                                                                                                                                                                                                                                             * забирает оттуда часть задач себе (обычно с другого конца deque, чтобы не ломать порядок).
Что это даёт:
                                                                                                                                                                                                                                             * нет необходимости в центральном “диспетчере” → меньше блокировок;
                                                                                                                                                                                                                                             * нагрузка равномернее между потоками;
                                                                                                                                                                                                                                             * задачи “перетекают” от перегруженных worker’ов к свободным.
Kotlin’овский DefaultDispatcher устроен именно так: это небольшой work-stealing scheduler.
 12. Какие планировщики есть в Kotlin/Android
Переключение потока = результат того, что resumeWith корутины прокинулось через DispatchedContinuation, а тот, в зависимости от Dispatcher, либо:
                                                                                                                                                                                                                                             * сразу вызывает delegate.resumeWith в текущем потоке (isDispatchNeeded == false),
                                                                                                                                                                                                                                             * либо кладёт runnable в очередь нужного пула/Handler’а и уже там вызывает resumeWith.
Глобальный scheduler для 
Dispatchers.Default / Dispatchers.IO
                                                                                                                                                                                                                                             * Общий work-stealing пул для CPU-задач и IO-задач.
                                                                                                                                                                                                                                             * IO-задачи помечаются как “blocking”, и scheduler может временно поднять доп. worker-ы, чтобы они не душили CPU-корутины.
Main-loop для 
Dispatchers.Main (Android)
                                                                                                                                                                                                                                             * Здесь “планировщик” — это Looper/Handler:
                                                                                                                                                                                                                                             * dispatch(context, block) → handler.post(block);
                                                                                                                                                                                                                                             * Looper в UI-потоке крутит очередь сообщений и вызывает Runnable.run().
                                                                                                                                                                                                                                             * Корутинный scheduler здесь построен поверх классического Android event loop.
Локальные event loop’ы (runBlocking, delay вне Default)
                                                                                                                                                                                                                                             * У runBlocking есть свой BlockingEventLoop:
                                                                                                                                                                                                                                             * пока корутина внутри runBlocking ждёт, joinBlocking() крутит маленький event loop:
                                                                                                                                                                                                                                             * принимает задачи,
                                                                                                                                                                                                                                             * выполняет их в том же потоке,
                                                                                                                                                                                                                                             * блокирует поток только когда совсем нет работы.
                                                                                                                                                                                                                                             * Для delay на single-thread dispatcher’е тоже используется таймер + event loop.
12. как под капотом корутина переключается между тредами?
Через:
                                                                                                                                                                                                                                             1. Перехваченный continuation → DispatchedContinuation (в нём dispatcher).
                                                                                                                                                                                                                                             2. При resumeWith:
                                                                                                                                                                                                                                             * isDispatchNeeded → если true, вызывается dispatcher.dispatch(context, this).
                                                                                                                                                                                                                                             3. dispatch кладёт Runnable (continuation) в очередь нужного планировщика.
                                                                                                                                                                                                                                             4. Какой-то worker-поток берёт Runnable и вызывает run() → корутина продолжает уже на этом потоке.

13. IO-задачи отмечаются как “blocking”; как это влияет?
Планировщик знает: “вот эти задачи могут долго сидеть в блокирующем вызове”. Он:
                                                                                                                                                                                                                                                * может временно поднять больше потоков поверх Default-пула, чтобы блокирующие IO не забили все worker’ы;

                                                                                                                                                                                                                                                * но держит глобальный лимит, чтобы не создать 1000 потоков.

Для нас это значит: всё блокирующее — в Dispatchers.IO, иначе забьём Dispatchers.Default.
14. isDispatchNeeded — это про “надо ли переключиться на другой поток”?
Да. Он решает:
                                                                                                                                                                                                                                                   * если false — можно выполнить continuation сразу в текущем потоке (без hop’а);
                                                                                                                                                                                                                                                   * если true — нужно отдать задачу планировщику (dispatch), который уже решит, на каком потоке её выполнить.
15. чем dispatchYield отличается от dispatch?
Оба ставят задачу в очередь, но:
                                                                                                                                                                                                                                                   * dispatch — обычная постановка (как “сделай это как можно скорее”);
                                                                                                                                                                                                                                                   * dispatchYield — для yield(): задача ставится в конце очереди / как low-priority, чтобы дать шанс поработать другим задачам.

16. Любая suspend функция может работать на разных потоках?
Любая suspend-функция сама по себе ничего не знает о потоках. Компилятор превращает её в state-machine с Continuation, а реальный поток выполнения определяется CoroutineDispatcher в контексте корутины.


Между точками подвеса (suspend-вызовами) та же корутина легко может продолжаться на разных потоках: её continuation резюмируется через DispatchedContinuation, который отдаёт выполнение в пул потоков (Default, IO) или в Handler main-потока. Поэтому одна и та же suspend-функция, вызванная в одном launch, может выполнить первую половину на одном worker’е, затем из-за delay — продолжиться на другом.


С другой стороны, если корутина работает в контексте, который всегда исполняется на одном потоке (например, Dispatchers.Main без withContext на другие диспетчеры, или single-thread dispatcher), то весь вызов suspend-функции фактически отработает на одном и том же потоке.


Single-thread dispatcher — это CoroutineDispatcher, который работает поверх одного OS-потока и очереди задач. Всё, что выполняется в этом dispatcher’е, всегда происходит на одном и том же thread’е, что удобно для thread-confinement, когда не хочется думать о синхронизации.


withContext — это suspend-функция, которая временно переключает выполнение корутины в другой контекст (обычно с другим dispatcher’ом). Внутри он создаёт дочернюю корутину с новым контекстом, подвешивает родительскую и, когда блок завершился, резюмирует родителя, возвращая результат.


Одна и та же логическая корутина за время работы может несколько раз вызывать withContext с разными dispatcher’ами, поэтому разные части её кода выполняются на разных тредпулаx: кусок на Main, кусок на IO, кусок на Default и т.д. Но в каждый момент времени у неё один текущий контекст и один dispatcher; “параллельно” она не бежит на нескольких потоках — только последовательно, через suspension/resume.
17. Какие есть flow, как работают под капотом
В kotlinx.coroutines есть несколько видов Flow:
                                                                                                                                                                                                                                                      * Холодный Flow<T> — ленивый, каждый collect заново запускает всю цепочку операторов. Под капотом это просто интерфейс с suspend fun collect(FlowCollector<T>), а операторы (map, filter, и т.д.) реализованы как обёртки, которые внутри вызывают upstream.collect { emit(...) }. Всё выполняется в одном корутинном контексте и последовательно, пока ты не вставишь такие операторы как buffer или flowOn.

                                                                                                                                                                                                                                                      * flowOn, buffer, conflate, flatMapMerge добавляют асинхронность: под капотом они создают дополнительные корутины и каналы между частями pipeline’а, чтобы producer и consumer могли работать независимо, часто на разных dispatcher’ах.

                                                                                                                                                                                                                                                      * SharedFlow — горячий поток, который живёт независимо от коллектора. Внутри у него есть общий буфер (replay cache) и список подписчиков; emit добавляет значение в буфер и раздаёт его всем активным коллекторам.

                                                                                                                                                                                                                                                      * StateFlow — специальный случай SharedFlow для состояния: всегда есть одно актуальное значение, при collect сначала получаем текущее, потом все обновления. Фактически реализован поверх SharedFlow с replay = 1 и хранением последнего значения.

                                                                                                                                                                                                                                                      * channelFlow и callbackFlow — билдеры Flow, которые под капотом используют Channel<T>: внутри них мы можем запускать разные корутины или подписываться на callback-API и посылать события в канал, а Flow при сборе читает из канала и отдаёт элементы downstream’у.



Общий принцип: Flow — это последовательность элементов, описанная как цепочка collect/emit; все операторы — просто новые обёртки над этим интерфейсом, а параллелизм и переключение dispatcher’ов появляются тогда, когда мы явно вставляем каналы/дополнительные корутины через buffer, flowOn, flatMapMerge, channelFlow и т.п.


18. Flow vs channel


Channel — это низкоуровневый примитив обмена сообщениями между корутинами: очередь send/receive, хорош для акторов и пайплайнов. Flow — это высокоуровневый поток значений, описанный как collect/emit с множеством операторов и интеграцией с coroutine context и жизненным циклом. Обычно внутри реализации можно использовать Channels, а наружу выдавать Flow/StateFlow/SharedFlow как стабильный реактивный API.
19. Концепция StructureCuncurrensy(организация связей между корутинами)


Structured concurrency — это концепция, по которой корутины в Kotlin образуют дерево Job’ов. Любой CoroutineScope имеет родительский Job, а все запущенные в нём launch/async/withContext становятся дочерними. Родитель ждёт завершения всех своих детей, а отмена и ошибки распространяются по этому дереву по понятным правилам: в обычном Job исключение в дочерней корутине отменяет родителя и всех остальных детей; в SupervisorJob — дети независимы по ошибкам, но по отмене всё равно управляются сверху.


Это решает классическую проблему “утёкших” фоновых задач и хаоса с потоками: как только scope заканчивает жизнь (например, runBlocking возвращает, ViewModel уничтожена, lifecycle завершён), гарантируется, что либо все корутины внутри завершились, либо были отменены. Поэтому в приложении мы почти всегда запускаем корутины из контролируемых scope’ов (viewModelScope, lifecycleScope, coroutineScope), а не из GlobalScope.


20. ЖЦ корутины, откуда они знают о своих родителях/детях, ЖЦ Thread
У потока (OS Thread) есть свои состояния (JVM):
NEW
                                                                                                                                                                                                                                                         * Thread создан (Thread t = new Thread(...)), но t.start() ещё не вызвали.
                                                                                                                                                                                                                                                         * Код run() ни разу не выполнялся.
RUNNABLE
                                                                                                                                                                                                                                                         * Поток готов к выполнению или выполняется прямо сейчас.
                                                                                                                                                                                                                                                         * JVM не различает “в очереди на CPU” и “на CPU”.

То есть:
                                                                                                                                                                                                                                                            * либо реально крутится на ядре,
                                                                                                                                                                                                                                                            * либо ожидает своей очереди в планировщике ОС.
BLOCKED
                                                                                                                                                                                                                                                            * Поток пытается войти в synchronized-блок / захватить монитор, который уже занят другим потоком.
                                                                                                                                                                                                                                                            * Он ждёт освобождения монитора.
WAITING
                                                                                                                                                                                                                                                            * Поток ждёт другого потока, без таймаута:
                                                                                                                                                                                                                                                            * Object.wait() без таймаута,
                                                                                                                                                                                                                                                            * Thread.join() без таймаута,
                                                                                                                                                                                                                                                            * LockSupport.park().
                                                                                                                                                                                                                                                            * Он не будет разбуден автоматически — нужно явное событие:
                                                                                                                                                                                                                                                            * notify()/notifyAll,
                                                                                                                                                                                                                                                            * завершение потока, который мы join’им,
                                                                                                                                                                                                                                                            * unpark.
TIMED_WAITING
                                                                                                                                                                                                                                                            * То же самое, но с таймаутом:
                                                                                                                                                                                                                                                            * Thread.sleep(millis) → TIMED_WAITING до истечения времени,
                                                                                                                                                                                                                                                            * Object.wait(timeout),
                                                                                                                                                                                                                                                            * Thread.join(timeout),
                                                                                                                                                                                                                                                            * LockSupport.parkNanos().
                                                                                                                                                                                                                                                            * Поток либо проснётся при событии, либо по таймауту.
TERMINATED
                                                                                                                                                                                                                                                            * Поток завершил метод run() (нормально или с исключением).
                                                                                                                                                                                                                                                            * Его больше нельзя start()ить снова.
                                                                                                                                                                                                                                                            * join() на таком потоке вернётся сразу.
У корутины есть свои состояни:
                                                                                                                                                                                                                                                            * New
                                                                                                                                                                                                                                                            * корутина создана, но ещё не запущена
                                                                                                                                                                                                                                                            * бывает при launch(start = CoroutineStart.LAZY) / async(start = LAZY)
                                                                                                                                                                                                                                                            * Active
                                                                                                                                                                                                                                                            * корутина запущена, выполняет свой код (между точками suspend)
                                                                                                                                                                                                                                                            * состояние после обычного launch {} / async {}
                                                                                                                                                                                                                                                            * Completing
                                                                                                                                                                                                                                                            * корутина закончила выполнение тела, но:
                                                                                                                                                                                                                                                            * ждёт завершения финализаторов,
                                                                                                                                                                                                                                                            * или детей (если это scope-корутина).
                                                                                                                                                                                                                                                            * Cancelling
                                                                                                                                                                                                                                                            * cancel() вызван (или родитель отменил, или исключение)
                                                                                                                                                                                                                                                            * корутина ещё «дожёвывает» finally {} / try { } catch.

                                                                                                                                                                                                                                                               * Cancelled / Completed
                                                                                                                                                                                                                                                               * закончила жизнь:
                                                                                                                                                                                                                                                               * либо успешно → Completed,
                                                                                                                                                                                                                                                               * либо с отменой/ошибкой → Cancelled (с CancellationException или другим Throwable).
В Job это зашито внутри (есть state-машина, CAS’ы и т.п., но на собесе достаточно этой логики).
20. Откуда корутина знает про родителя и детей?
Родитель–ребёнок в корутинах — это дерево Job’ов, где корень берётся из CoroutineContext, а launch/async/withContext создают новые Job’ы и прикрепляют их к parentJob.
                                                                                                                                                                                                                                                               * родитель хранит список своих детей (children: Set<Job>),
                                                                                                                                                                                                                                                               * ребёнок хранит ссылку на родителя (parentHandle).

StandaloneCoroutine — корневая корутина без parent’а.
ChildCoroutine — обычный “ребёнок”, который входит в дерево Job’ов и влияет на родителя/братьев по правилам structured concurrency.
21. Что такое Job(примитив с точки зрения корутин) и Deffered
Job Это:
                                                                                                                                                                                                                                                                  * handle жизненного цикла корутины/скоупа:
                                                                                                                                                                                                                                                                  * состояние (New, Active, Cancelling, Completed, …),
                                                                                                                                                                                                                                                                  * ссылки на родителей и детей,
                                                                                                                                                                                                                                                                  * API cancel, invokeOnCompletion, children.
Он не знает, какой именно код выполняется — только “живём/умираем/отменяемся”.
Continuation Это:
                                                                                                                                                                                                                                                                  * “где продолжать” и “что делать дальше” для конкретной корутины:
                                                                                                                                                                                                                                                                  * ссылка на state-machine (invokeSuspend),
                                                                                                                                                                                                                                                                  * локальные переменные (label, поля),
                                                                                                                                                                                                                                                                  * CoroutineContext.
В байткоде:
                                                                                                                                                                                                                                                                  * suspend fun превращается в класс, наследующий ContinuationImpl,
                                                                                                                                                                                                                                                                  * у него есть метод invokeSuspend(result) со when(label).
Continuation не хранит дерево родитель/дети, не управляет отменой сам по себе — но внутри context лежит Job, так что:
Как они работают вместе
                                                                                                                                                                                                                                                                  * Continuation знает, как продолжить вычисление (invokeSuspend).
                                                                                                                                                                                                                                                                  * Job знает, можно ли вообще продолжать (не отменён ли), и кто ещё зависит от этого.
При suspend:
                                                                                                                                                                                                                                                                  1. корутина сохраняет состояние в continuation;
                                                                                                                                                                                                                                                                  2. возвращает COROUTINE_SUSPENDED;
                                                                                                                                                                                                                                                                  3. позже кто-то вызывает continuation.resumeWith(result) → уже через DispatchedContinuation, который проверяет dispatcher, кладёт задачу в планировщик;
                                                                                                                                                                                                                                                                  4. внутри invokeSuspend часто есть проверки вида ensureActive(), которые читают состояние Job.
В Kotlin корутина на уровне рантайма — это Continuation + CoroutineContext, где лежит Job, Dispatcher и другие элементы. Компилятор превращает suspend-функцию в state-machine (ContinuationImpl), а Job — это корутинный примитив, который описывает жизненный цикл этой корутины: состояние, отмену и связи родитель–дети.


Когда мы вызываем launch, создаётся объект, который одновременно реализует Job и Continuation<Unit> (StandaloneCoroutine или ChildCoroutine) — он регистрируется как дочерний Job в родительском scope и управляет выполнением тела корутины, но, по сути, без значимого результата.


Когда мы вызываем async, создаётся DeferredCoroutine<T>, который тоже является и Job, и Continuation<T>, но дополнительно хранит результат и даёт await(). То есть Deferred<T> — это просто Job с результатом, аналог Future<T> в корутинном мире, тогда как обычный Job — это “fire-and-forget” задача без значения результата (понятийно — Deferred<Unit>).
22. Способы создания потока, на что расходуются ресурсы при создании потока
Когда ты делаешь new Thread().start() (или эквивалент через Executors), происходит следующее:
2.1. На уровне ОС (kernel)
Создаётся kernel thread — сущность, которую видит OS-планировщик:
                                                                                                                                                                                                                                                                  1. Выделяется стек потока (native stack)
                                                                                                                                                                                                                                                                  * Обычно несколько сотен килобайт – мегабайт.
                                                                                                                                                                                                                                                                  * На JVM часто по умолчанию 1 МБ на поток (можно менять -Xss).
                                                                                                                                                                                                                                                                  * Виртуальный адресный диапазон резервируется сразу, физическая память коммитится по мере роста стека.
                                                                                                                                                                                                                                                                  * Но: чем больше потоков → тем больше зарезервировано адресного пространства, и тем больше потенциальной физической памяти будет съедено.

                                                                                                                                                                                                                                                                     2. Создаётся Thread Control Block (TCB)
                                                                                                                                                                                                                                                                     * Структура в ядре, где:
                                                                                                                                                                                                                                                                     * id потока (TID),
                                                                                                                                                                                                                                                                     * указатели на стек, регистры,
                                                                                                                                                                                                                                                                     * состояние (RUNNABLE/BLOCKED и т.д.),
                                                                                                                                                                                                                                                                     * информация для планировщика.

                                                                                                                                                                                                                                                                        3. Регистрация в планировщике ОС
                                                                                                                                                                                                                                                                        * Поток добавляется в структуры данных планировщика (run-queue и др.).
                                                                                                                                                                                                                                                                        * ОС будет учитывать его при распределении CPU-времени между потоками.
                                                                                                                                                                                                                                                                        4. Kernel resources / handle
                                                                                                                                                                                                                                                                        * Дескриптор потока (handle),
                                                                                                                                                                                                                                                                        * записи в таблицах ядра.
Это всё — системные вызовы + работа ядра → уже ощутимое время.
2.2. На уровне JVM
Параллельно с OS-thread JVM создает свои структуры:
                                                                                                                                                                                                                                                                        1. Объект java.lang.Thread в heap’е
                                                                                                                                                                                                                                                                        * Поля: имя, приоритет, флаги (daemon), Runnable target, ThreadGroup, ThreadLocal-карта и т.д.
                                                                                                                                                                                                                                                                        * Ссылка на “native peer” — нативную структуру, которая связывает этот объект с kernel thread.
                                                                                                                                                                                                                                                                        2. Пер-потоковые структуры JVM
                                                                                                                                                                                                                                                                        * Per-thread данные JIT-а, GC, профилировщика.
                                                                                                                                                                                                                                                                        * Пер-потоковые буферы, например, для ThreadLocal, локальные буферы логов и пр.
                                                                                                                                                                                                                                                                        3. Stack + Java frames
                                                                                                                                                                                                                                                                        * Native stack (OS),
                                                                                                                                                                                                                                                                        * на нём — текущие фреймы вызовов JVM (интерпретатор / JIT-код).
                                                                                                                                                                                                                                                                        4. GC root
                                                                                                                                                                                                                                                                        * Любой живой поток — это корень GC (root):
                                                                                                                                                                                                                                                                        * его стек и ThreadLocal-поля — места, откуда GC начинает поиск достижимых объектов.
                                                                                                                                                                                                                                                                        * Больше потоков → больше корней → чуть сложнее GC-проходы.

2.3. Что дорого при создании потока
                                                                                                                                                                                                                                                                           1. Память под стек
                                                                                                                                                                                                                                                                           * Допустим, 1 МБ на поток.
                                                                                                                                                                                                                                                                           * 1000 потоков → до 1 ГБ виртуального адресного пространства под стеки.
                                                                                                                                                                                                                                                                           * Физически память выдается по мере использования, но всё равно:
                                                                                                                                                                                                                                                                           * каждый стек = guard pages, PTE-записи, потенциальный риск упора в лимиты.
                                                                                                                                                                                                                                                                           2. Системные вызовы + работа ядра
                                                                                                                                                                                                                                                                           * Создание kernel thread — это не просто malloc():
                                                                                                                                                                                                                                                                           * нужно завести TCB,
                                                                                                                                                                                                                                                                           * зарегистрировать поток в планировщике,
                                                                                                                                                                                                                                                                           * настроить начальное состояние регистров, указатель стека, return address.
                                                                                                                                                                                                                                                                           * Это гораздо дороже, чем создать обычный объект в heap.
                                                                                                                                                                                                                                                                           3. Нагрузка на планировщик
                                                                                                                                                                                                                                                                           * Чем больше потоков:
                                                                                                                                                                                                                                                                           * тем больше работы у OS-планировщика при выборе, кого запускать,
                                                                                                                                                                                                                                                                           * тем больше контекст-переключений (context switch):
                                                                                                                                                                                                                                                                           * сохранение/восстановление регистров,
                                                                                                                                                                                                                                                                           * кеш-память (L1/L2) “засоряется”, падает cache locality.
                                                                                                                                                                                                                                                                           4. Создание потока → ещё одна единица, которую планировщик должен учитывать.
                                                                                                                                                                                                                                                                           5. Пер-потоковые структуры JVM
                                                                                                                                                                                                                                                                           * На каждый поток — свои метаданные:
                                                                                                                                                                                                                                                                           * ThreadLocal-слоты,
                                                                                                                                                                                                                                                                           * буферы,
                                                                                                                                                                                                                                                                           * структуры для JIT-профилирования,
                                                                                                                                                                                                                                                                           * внутренние lock’и.

                                                                                                                                                                                                                                                                              * Это не мегабайты, но суммарно 1000 потоков → десятки/сотни МБ памяти легко.

Поток на JVM создаётся либо напрямую через new Thread().start(), либо через абстракции вроде Executors.newFixedThreadPool, ForkJoinPool, CompletableFuture.supplyAsync, thread {} и т.д. Во всех этих случаях внутри создаётся нативный поток ОС.
При создании потока расходуются ресурсы на двух уровнях:
                                                                                                                                                                                                                                                                                 * На уровне операционной системы:
создаётся kernel thread — выделяется стек (обычно порядка мегабайта), создаётся Thread Control Block, поток регистрируется в планировщике, заводится дескриптор/handle. Это системные вызовы и достаточно дорого по времени.

                                                                                                                                                                                                                                                                                 * На уровне JVM:
создаётся объект java.lang.Thread и связанные с ним структуры (native peer, ThreadLocal-таблицы, пер-потоковые данные JIT/GC). Дополнительно каждый поток становится GC-root, растёт объём метаданных для планировщика.
Поэтому создание потока — тяжёлая операция, и держать тысячи потоков невыгодно. Обычно создают ограниченный пул потоков (ExecutorService) и переиспользуют их, а для большого числа логических задач используют легковесные сущности вроде корутин, которые мультиплексируются поверх малого числа потоков.
В Java основа — это интерфейс Executor, который просто умеет выполнять Runnable. На его базе есть ExecutorService (поддерживает shutdown и Future) и ScheduledExecutorService (планирование задач по времени).
23. Какие есть executors


Через Executors есть несколько стандартных реализаций:
                                                                                                                                                                                                                                                                                    * newSingleThreadExecutor — один поток, все задачи по очереди;
                                                                                                                                                                                                                                                                                    * newFixedThreadPool(n) — пул из N потоков, лишние задачи в очереди;
                                                                                                                                                                                                                                                                                    * newCachedThreadPool() — пул с динамическим числом потоков, использует SynchronousQueue, подходит для краткоживущих задач, но может раздуть много потоков;
                                                                                                                                                                                                                                                                                    * newScheduledThreadPool(n) — пул для отложенных и периодических задач (schedule, scheduleAtFixedRate);
                                                                                                                                                                                                                                                                                    * newWorkStealingPool() — пул на базе ForkJoinPool с work-stealing.
Все эти фабрики внутрях создают один из наследников Executor, чаще всего ThreadPoolExecutor или ScheduledThreadPoolExecutor.
24. Всегда ли код выполняется в том порядке, в котором он написан?
                                                                                                                                                                                                                                                                                    * В пределах одного потока — да, по спецификации языка программа ведёт себя как будто инструкции выполняются по порядку. Компилятор и CPU могут переупорядочивать, но не могут изменить наблюдаемое поведение однопоточного кода.

                                                                                                                                                                                                                                                                                    * Между потоками — нет. Без корректной синхронизации (happens-before через synchronized, volatile, atomics, locks и т.д.) компилятор и процессор могут переупорядочивать операции, кэшировать данные и т.д., поэтому другой поток может видеть записи в другом порядке, чем они идут в исходном коде.
→ останется только a = 2.
Кто и как ломает порядок
Компилятор / JIT
JIT может:
                                                                                                                                                                                                                                                                                       * переупорядочивать независимые инструкции если нет зависимостей и синхронизации между ними.
                                                                                                                                                                                                                                                                                       * выносить вычисления из циклов,
                                                                                                                                                                                                                                                                                       * сливать записи
                                                                                                                                                                                                                                                                                       * менять расположение проверок и вызовов, если по спецификации это допустимо.

Процессор
Даже если байткод / машинный код в правильном порядке, CPU может:
                                                                                                                                                                                                                                                                                          * выполнять команды out-of-order ради оптимизации pipeline;
                                                                                                                                                                                                                                                                                          * использовать store buffer:
                                                                                                                                                                                                                                                                                          * поток записал a = 1 → запись пока в буфере, ещё не “дошла” до общей памяти;
                                                                                                                                                                                                                                                                                          * другой поток видит старое a = 0.
Кэш / память
                                                                                                                                                                                                                                                                                          * У каждого ядра — свой кеш.
                                                                                                                                                                                                                                                                                          * Записи одного ядра не мгновенно видны другим.
                                                                                                                                                                                                                                                                                          * Без барьеров/синхронизации разные ядра могут видеть память в разном порядке.
Архитектура


1. Чем MVI отличаются от MVVM


MVVM:


View  <── observes ──  ViewModel  ── обращается ──>  Model/Repository
  │                                                  ▲ 
  └─── пользовательские ────┘
             события (клики)
                                                                                                                                                                                                                                                                                          * View:
                                                                                                                                                                                                                                                                                          * слушает LiveData / StateFlow из VM,
                                                                                                                                                                                                                                                                                          * вызывает методы VM (onButtonClick(), onTextChanged()).
                                                                                                                                                                                                                                                                                          * ViewModel:
                                                                                                                                                                                                                                                                                          * хранит поля состояния (LiveData, StateFlow),
                                                                                                                                                                                                                                                                                          * при событиях меняет эти поля,
                                                                                                                                                                                                                                                                                          * ходит в репозитории/UseCase’ы.
Состояние экрана нередко разбросано по нескольким полям:
val isLoading: LiveData<Boolean>
val items: LiveData<List<Item>>
val error: LiveData<String?>


MVI:
       ┌───────────────┐
        │           View (UI)             │
        └──────┬────────┘
                          │ Intents (события/намерения)
                         ▼
       ┌────────────────┐
       │          ViewModel /            │
       │                Store                 │
       └──────┬─────────┘
                 State│ (новый снапшот)
                         ▼
        ┌───────────────┐
        │             View (UI)           │
        └───────────────┘
3 главные сущности:
                                                                                                                                                                                                                                                                                          1. Intent — намерение пользователя / события UI:
                                                                                                                                                                                                                                                                                          * OnRefreshClicked, OnItemClicked(id), OnQueryChanged(query)…
                                                                                                                                                                                                                                                                                          2. State — полная фотография экрана:
data class UiState(
    val isLoading: Boolean = false,
    val items: List<Item> = emptyList(),
    val error: String? = null,
)
                                                                                                                                                                                                                                                                                          3. Reducer — чистая функция:
fun reduce(old: UiState, event: Event): UiState
View:
                                                                                                                                                                                                                                                                                          * только отправляет Intents,
                                                                                                                                                                                                                                                                                          * только рендерит State.

MVVM и MVI — это не конкурирующие фреймворки, а два разных стиля организации слоёв presentation. В MVVM у нас есть View, которая наблюдает за ViewModel (через LiveData/Flow) и вызывает её методы. Состояние экрана часто хранится в нескольких полях, которые ViewModel по месту мутирует. Поток данных на практике почти однонаправленный, но жёстких правил немного.


В MVI поток строго однонаправленный: View порождает Intents (намерения пользователя), ViewModel/Store преобразует их в новый UiState через редьюсеры, и View просто рендерит этот state. Состояние экрана — обычно один неизменяемый data class, и мы всегда создаём новый state через copy, вместо того чтобы менять несколько полей. Плюс часто есть отдельный канал для одноразовых эффектов (навигация, тосты).


MVVM проще стартовать, меньше бойлерплейта. MVI даёт более жёсткую структуру, легче тестировать и контролировать консистентность состояния, особенно с Compose, но требует больше типов и дисциплины.
2. Луковая архитектура(Clean) и слоистая архитектура
Слоистая архитектура — это просто разделение на уровни: Presentation, Domain, Data. Верхние слои используют нижние. Но строгих правил зависимости обычно нет: домен может напрямую знать про инфраструктуру, а UI иногда обращается сразу к репозиториям.


Луковая/Clean — это более строгий вариант: домен в центре, и все зависимости направлены только внутрь. Домен не зависит ни от фреймворков, ни от БД, ни от сети. В нём только бизнес-модели и use case’ы. Внешние слои (data, UI, инфраструктура) реализуют интерфейсы, определённые в домене, через dependency inversion. Это делает домен переиспользуемым и хорошо тестируемым, но требует больше абстракций и дисциплины.