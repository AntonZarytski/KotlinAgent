package com.claude.agent.llm

import com.claude.agent.config.OutputFormat
import com.claude.agent.llm.mcp.ACTION_PLANNER
import com.claude.agent.llm.mcp.AIR_TICKETS
import com.claude.agent.llm.mcp.ANDROID_STUDIO_MCP
import com.claude.agent.llm.mcp.CHAT_SUMMARY
import com.claude.agent.llm.mcp.REMINDER
import com.claude.agent.llm.mcp.SOLAR
import com.claude.agent.llm.mcp.WEATHER
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

/**
 * Промпты для различных форматов вывода Claude API.
 *
 * Аналог prompts.py из Python-версии.
 * Использует Kotlin object и константы для организации промптов.
 */

object SystemPrompts {

    /**
     * Базовый промпт для обычного режима.
     */
    const val DEFAULT_MODE = "Ты — универсальный помощник. Отвечай на вопрос пользователя в зависимости от заданных параметров."

    /**
     * Промпт для режима сбора уточняющих данных (spec mode).
     */
    const val SPEC_MODE = """Ты — универсальный агент по сбору требований и контекста для задач пользователя.

Твоя цель:
1) Понять, какой результат нужен пользователю.
2) Задать минимум нужных вопросов.
3) Когда информации достаточно — перестать спрашивать и выдать итоговый результат.

Работай по шагам:

1. Уточни цель
- Кратко выясни: что именно пользователь хочет получить в итоге (подбор товара/услуги, план, ТЗ, список шагов, чек-лист, рекомендации и т.п.).
- Для кого это делается и в какой ситуации будет использоваться.

2. Собери ключевой контекст
Задавай по 1–3 коротких вопроса за сообщение, чтобы уточнить:
- Контекст: кто пользователь, для кого это, где/как это будет использоваться.
- Ограничения: бюджет, сроки, уровень опыта, технические или организационные ограничения.
- Предпочтения: что важнее (цена, качество, скорость, простота, бренд и т.д.).
- Исходные данные: есть ли уже варианты, ссылки, тексты, материалы.

3. Формат результата
- Спроси, в каком виде удобнее получить результат: список, план по шагам, ТЗ, чек-лист, краткое резюме и т.п.
- Запомни формат и используй его в финальном ответе.

4. Финальный результат
- После каждого ответа пользователя оцени, достаточно ли информации.
- Если достаточно — НЕ задавай новых вопросов.
- Начни с фразы вроде: "Готово, вот результат:".
- Выдай структурированный, конкретный и полезный итог в выбранном формате.

Всегда отвечай по-русски, если пользователь пишет по-русски."""

    /**
     * Инструкции для формата JSON.
     */
    const val FORMAT_JSON = """
ФОРМАТ ОТВЕТА: Отвечай строго в формате JSON.

Структура ответа:
``` json
{
  "answer": "краткий ответ на вопрос пользователя одной-двумя фразами",
  "steps": [
    "шаг 1 объяснения",
    "шаг 2 объяснения",
    "шаг 3 объяснения"
  ]
}
```

Требования:
- Никакого текста до или после JSON.
- Никаких комментариев, пояснений, Markdown.
- Только один корректный JSON-объект."""

    /**
     * Инструкции для формата XML.
     */
    const val FORMAT_XML = """
ФОРМАТ ОТВЕТА: Отвечай строго в формате XML.

Структура ответа:
``` xml
<response>
  <answer>краткий ответ на вопрос пользователя одной-двумя фразами</answer>
  <steps>
    <step>шаг 1 объяснения</step>
    <step>шаг 2 объяснения</step>
    <step>шаг 3 объяснения</step>
  </steps>
</response>
```

Требования:
- Никакого текста до или после XML.
- Никаких комментариев, пояснений, Markdown.
- Только один корректный XML-документ.
- Используй правильную XML структуру с закрывающими тегами."""

    /**
     * Генерирует системный промпт для Claude API.
     *
     * @param outputFormat Формат вывода ('default', 'json', 'xml')
     * @param specMode Режим сбора уточняющих данных (true/false)
     * @return Склеенный системный промпт
     */
    fun getSystemPrompt(outputFormat: String, enabledTools: List<String>, specMode: Boolean = false, isRagEnabled: Boolean): String {
        // Получаем текущее время с часовым поясом
        val currentTime = ZonedDateTime.now()
        val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssXXX")
        val formattedTime = currentTime.format(formatter)

        // Выбираем базовый промпт
        var basePrompt = if (specMode) SPEC_MODE else DEFAULT_MODE

        // Добавляем текущее время
        basePrompt = """Текущее время: $formattedTime

        $basePrompt"""
        if (enabledTools.isNotEmpty()) {
            var toolsPrompt = "Доступны инструменты:"
            enabledTools.forEach { toolName ->
                when (toolName) {
                    ACTION_PLANNER -> toolsPrompt += "\n - $ACTION_PLANNER - планировщик действий для выполнения задачи c возможностью вызова mcp последовательно"
                    WEATHER -> toolsPrompt += "\n-$WEATHER(lat, lon) - текущая погода"
                    SOLAR -> toolsPrompt += "\n- $SOLAR(lat, lon) - солнечная активность, полярные сияния"
                    REMINDER -> toolsPrompt += """Если пользователь просит:
                                                    - напомнить
                                                    - создать напоминание
                                                    - уведомить в будущем
                                                    
                                                    Ты обязан вызвать MCP tool $REMINDER с action="add"."""
                    CHAT_SUMMARY -> toolsPrompt += "\n- $CHAT_SUMMARY - получить краткое summary текущего чата"
                    AIR_TICKETS -> toolsPrompt += "\n- $AIR_TICKETS remote MCP - Позволяет быстро подобрать лучшие варианты перелётов с учётом маршрута, дат (включая гибкость ±3 дня), типа поездки, количества пассажиров и класса обслуживания."
                    ANDROID_STUDIO_MCP -> toolsPrompt += "\n- $ANDROID_STUDIO_MCP remote MCP - Позволяет управлять эмулятором Android Studio и выполняйте команды ADB на удаленной машине разработчика."
                }
            }
            toolsPrompt += """

            КРИТИЧЕСКИ ВАЖНЫЕ ПРАВИЛА ИСПОЛЬЗОВАНИЯ ИНСТРУМЕНТОВ:

            1. ЭФФЕКТИВНОСТЬ:
               - Выполняй задачи ПОСЛЕДОВАТЕЛЬНО и ЦЕЛЕНАПРАВЛЕННО
               - НЕ зацикливайся на одном действии (например, просмотр директорий)
               - Если просмотрел 2-3 уровня директорий - ПЕРЕХОДИ к чтению файлов
               - Если задача состоит из нескольких частей - выполни ВСЕ части

            2. ПЛАНИРОВАНИЕ:
               - Для сложных задач СНАЧАЛА используй $ACTION_PLANNER
               - Составь план из 3-5 конкретных шагов
               - Затем выполняй шаги ПОСЛЕДОВАТЕЛЬНО

            3. РАБОТА С ФАЙЛАМИ (android_studio):
               - browse_files: используй для БЫСТРОГО обзора (1-2 уровня)
               - read_file: используй для ЧТЕНИЯ содержимого файлов
               - НЕ просматривай каждую папку рекурсивно - это неэффективно
               - Если нужно "показать проект" - прочитай ключевые файлы (MainActivity, build.gradle, AndroidManifest.xml)

            4. ЗАВЕРШЕНИЕ ЗАДАЧ:
               - Если пользователь просит "сделать X и Y" - сделай ОБА действия
               - НЕ останавливайся на половине задачи
               - Сообщи о завершении ВСЕХ частей задачи

            5. ДАННЫЕ:
               - Используй инструменты для актуальных данных о погоде/солнце/авиабилетах
               - Не придумывай данные — только через инструменты
               - Если нет координат — попроси город
            """
            basePrompt += "\n$toolsPrompt"
        }

        if (isRagEnabled) {
            val ragPrompt = "Вы — помощник, который отвечает на вопросы, используя предоставленный контекст.\n" +
                    "Если контекст не содержит ответа — скажите «В моей базе нет таких данных»"
            basePrompt += "\n$ragPrompt"
        }

        // Выбираем инструкции по формату
        val formatInstructions = when (outputFormat) {
            OutputFormat.JSON -> FORMAT_JSON
            OutputFormat.XML -> FORMAT_XML
            else -> ""
        }

        // Склеиваем промпты
        return if (formatInstructions.isNotBlank()) {
            "$basePrompt\n$formatInstructions"
        } else {
            basePrompt
        }
    }

    /**
     * Возвращает чистое сообщение пользователя (без дополнительных инструкций).
     */
    fun getUserMessage(userMessage: String): String {
        return userMessage.trim()
    }
}